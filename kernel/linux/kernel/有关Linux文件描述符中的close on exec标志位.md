[toc]



转自：https://blog.csdn.net/ddppqq/article/details/13095723



首先说明下文件描述符，文件描述符标志，文件状态标志的区别：
文件描述符：标识文件用的；
文件描述符标志（目前就只有一个close-on-exec）：仅仅是一个标志，当进程fork一个子进程的时候，在子进程中调用了exec函数时就用到了该标志。意义是执行exec前是否要关闭这个文件描述符；
文件状态标志：是在系统文件表中，关于write、read等标志。

close_on_exec 是一个进程所有文件描述符（文件句柄）的位图标志，每个比特位代表一个打开的文件描述符，用于确定在调用系统调用execve()时需要关闭的文件句柄（参见include/fcntl.h）。**当一个程序使用fork()函数创建了一个子进程时，通常会在该子进程中调用execve()函数加载执行另一个新程序。此时子进程将完全被新程序替换掉，并在子进程中开始执行新程序。若一个文件描述符在close_on_exec中的对应比特位被设置，那么在执行execve()时该描述符将被关闭，否则该描述符将始终处于打开状态。**



当打开一个文件时，默认情况下文件句柄在子进程中也处于打开状态。因此sys_open()中要复位对应比特位。

设置close on exec标志可通过fcntl(fd, F_SETFD, flags | FD_CLOEXEC)来进行设置，当然flags可先通过F_GETFD获得。

close on exec标志可有如下三个用途：

  1、如果调用了exec()，应该关闭指定的套接字；

  2、如果设置了此选项，则连接监听器设置所涉及的监听器套接字以close-on-exec标志；

  3、一般我们会调用exec执行另一个程序，此时会用全新的程序替换子进程的正文，数据，堆和栈等。此时保存文件描述符的变量当然也不存在了，我们就无法关闭无用的文件描述符了。所以通常我们会fork子进程后在子进程中直接执行close关掉无用的文件描述符，然后再执行exec。