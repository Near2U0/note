[TOC]



# 正规表达式与有限自动机

## 单词集合

* 语法描述的几个基本概念

  * **字母表**：一个有穷字符集：记为$\sum$

  * 字母表中的每个元素称为**字符**

  * $\sum$上的字(也叫字符串)，是指由$\sum$中的字符所构成的一个有穷序列

  * 不包含任何字符的序列称为**空字**，记为$\epsilon$

  * 用$\sum^*$表示$\sum$上的所有字的全体，包含空字$\epsilon$

  * 例如：设$\sum=\{a,b\}$,则

    ![image-20190420131207321](/Users/chenyansong/Documents/note/images/compileStud/20.png)

  * $\sum^*$的子集U和子集V的连接(积)定义为

    $$UV=\{\alpha\beta|\alpha\in U, \beta \in V\}$$

  * V自身的n次积记为

    ![image-20190420131715219](/Users/chenyansong/Documents/note/images/compileStud/21.png)

  * ![image-20190420131824692](/Users/chenyansong/Documents/note/images/compileStud/22.png)



## 正规集和正规式

* 描述单词
  * 正规集：程序设计语言定义的合法的单词的集合
  * 正规表达式(简称正规式)：正规式和正规集是一组对应的概念
  
* 正规式和正规集的关系

  ![image-20190420152850253](/Users/chenyansong/Documents/note/images/compileStud/25.png)

* 正规集可以用正规式表示，正规式是表示正规集的一种方法

* 正规式是正规集的抽象表示

* 一个字的集合是正规集，当且仅当他能用正规式表示

* 正规式和正规集的递归定义：
  * 对于给定的字母表$\sum$
    * $\epsilon$和$\varnothing$都是$\sum$上的正规式，他们所表示的正规集为$\{\epsilon\}$和$\{\varnothing\}$
  * 假定e1和e2都是$\sum$上的正规式，他们所表示的正规集为$L(e1)$和$L(e2)$,则：
    * (e1|e2)为正规式，他所表示的正规集为$L(e1) \cup L(e2)$
    * (e1*e2)为正规式(连接或者乘积)，他所表示的正规集为$L(e1)L(e2)$
    * $(e1)^*$为正规式，他所表示的正规集为$(L(e1))^*$

* 正规式的等价性

  ![image-20190420152244298](/Users/chenyansong/Documents/note/images/compileStud/23.png)

* 正规式的性质

  ![image-20190420152437132](/Users/chenyansong/Documents/note/images/compileStud/24.png)



## 确定有限自动机

Deterministic Finite Automata :DFA M是一个五元式 $M=(S,\sum,f,S_0,F)$

其中：

1. S是有穷的状态集

2. $\sum$是输入字母表(有穷)

3. f是**状态转换函数**，为$S*\sum->S$的单值映射，$f(s,a)=s^`$ , 表示：当现行状态为s，输入字符为a时，将状态转换到下一状态$s`$, $s`$称为s的一个后继状态

4. $S_0\in S$是唯一的一个初态

5. $F\subseteq S$:终态集(可空)，也就是手一个DFA允许没有终止状态

6. 举例

   ![image-20190420154112741](/Users/chenyansong/Documents/note/images/compileStud/26.png)

   f变成状态转换矩阵如下：

   ![image-20190420154244641](/Users/chenyansong/Documents/note/images/compileStud/27.png)



​	状态转换图如下：

​	![image-20190420154335242](/Users/chenyansong/Documents/note/images/compileStud/28.png)

* 确定有限自动机

  对于$\sum^*$中的任何字$\alpha$,若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于$\alpha$,则称$\alpha$为DFA M所识别(接受)

* DFA M所识别的字的全体记为L(M)



DFA是状态转换图的形式化的描述，很容易进行程序化的实现：实现为**一个二维矩阵+一个通用程序**的结构

![image-20190420162120431](/Users/chenyansong/Documents/note/images/compileStud/29.png)



## 非确定有限自动机

定义：一个**非确定有限自动机**(Nondeterministic Finite Automata, NFA) M,是一个五元式 $M=(S,\sum, f, S_0, F)$,其中：

1. S是有穷状态集
2. $\sum$是输入字母表(有穷)
3. f状态转换函数，为$S*\sum^*->2^S$，$f(S,\alpha)=S^`$,$\alpha$表示的是一个字(在NFA中表示的是一个字符)，经过f函数映射的结果是一个状态的集合(DFA中是唯一的一个状态)，即：从一种状态进过f之后，可能的后继有多个(非确定的含义)
4. $S_0 \subseteq S$ 是非空的初态集合(DFA中只有一个初态)
5. $F \subseteq S$:终态集(可空)



* NFA and DFA different
  * DNA的初态只有一个，而NFA的初态可以有多个
  * NFA经过f之后的映射只有唯一的值，但是DFA进过f映射之后可能有多个后继状态
* DFA更易于程序实现，但是DFA更易于设计
  
* 示例

  

  ![image-20190421092431416](/Users/chenyansong/Documents/note/images/compileStud/30.png)

  > 2->2状态的a|b就是一个正规式，对应的正规集为{a,b},表示从2出发识别了正规式{a,b}对应的正规集中的一个字符之后，就能再回到2状态(即：识别了一个a之后回到2，或者识别了一个b之后也能回到2)

  > 同一个字可能出现在同状态射出的额多条弧上，如上图：从0出发识别了一个a之后回到0，但是从0出发识别了一个a之后也可能走到1状态



* 判断两个自动机是否等价

  对于任何两个有限自动机$M和M`$,如果$L(M)=L(M`)$,则称$M和M`$等价
  
* DFA和NFA识别能力相同

  对于每个NFA M存在一个DFA $ M`$,使得$L(M)=L(M`)$





## NFA与NFA的等价性证明

对于每个NFA M存在一个DFA $M`$,使得$L(M)=L(M`)$，就可以得到NFA和DFA等价的结论

* DFA和NFA的区别

  ![image-20190421095046631](/Users/chenyansong/Documents/note/images/compileStud/31.png)

  只要消除了上面的NFA和DFA的区别，我们就可以实现NFA到DFA的转换	





* 消除初始状态和终态在唯一性上的差别

  引进新的初态节点X和终态节点Y，$X,Y \notin M$，从X到$S_0$中任意状态节点连一条线$\epsilon$箭弧，从F中任意状态节点连一条$\epsilon$箭弧到Y，这样就消除了NFA和DFA在初态上的唯一性的差别

  ![image-20190421100943703](/Users/chenyansong/Documents/note/images/compileStud/33.png)





* 消除中间状态

  对M的状态转换进一步实施行替换，其中k是新引入的状态

  ![image-20190421101053956](/Users/chenyansong/Documents/note/images/compileStud/34.png)

  ![image-20190421101222901](/Users/chenyansong/Documents/note/images/compileStud/35.png)



* NFA确定化-子集法(解决$\epsilon$弧和转换关系)
  * 设I是状态集的一个子集，定义I的$\epsilon$-闭包的$\epsilon-closure(I)$为：
    * 若$\epsilon \in I $,则$s \in \epsilon-closure(I)$;
    * 若$\epsilon \in I $,则从s出发进过任一条$\epsilon$弧而能到达的任何状态$s^`$都属于$s \in \epsilon-closure(I)$,即：
    
    $\epsilon-closure(I) = I \cup \{s^`|从某个s \in I 出发进过任意条 \epsilon 弧能到达s^`\}$
    
  * 设a是$\sum$中的一个字符，定义：
  
    $I_a= \epsilon-closure(J)$
  
    其中，J为I中的某个状态出发，严格的经过一条a弧而到达的状态集合
  
    定义了J之后，然后在对J做$\epsilon$的闭包，就得到了$I_a$的结果，所以I集合和$I_a$集合的图形关系如下：
  
    ![image-20190421103757327](/Users/chenyansong/Documents/note/images/compileStud/36.png)
    
    从I中的一个状态出发识别了一个字a，能够到达的一个状态一定在$I_a$里面；或者说，从I中的一个状态出发，经过若干条$\epsilon$弧再加上一条a弧，再加上若干个$\epsilon$弧，能够到达的状态也在$I_a$里面

* $\epsilon-closure(I)$举例说明

  ![image-20190421104823133](/Users/chenyansong/Documents/note/images/compileStud/37.png)

* DFA AND NFA的等价性证明

  * 确定化，不失一般性，设字母表只包含两个a和b，我们构造一张计算状态集的转换表：

    * 1.首先，置第1行第1列为$\epsilon-closure(\{X\})$，求出这一列的$I_a$和$I_b$

    * 然后，检查这两个$I_a$,$I_b$,看他们是否已在表中的第一列中出现，，把未曾出现的填入后面的空行的第一列上，求出每行第2，3列上的集合...

    * 重复上述过程，知道所有第2，3列子集全部出现在第一列上为止

      ![image-20190421105927067](/Users/chenyansong/Documents/note/images/compileStud/38.png)

* 示例：将状态之间的转换关系，转换成状态集之间的转换关系

  ![image-20190421110420297](/Users/chenyansong/Documents/note/images/compileStud/39.png)

* 将状态集进行编号，得到新的状态转换图，这样就真正的将NFA转换成为DFA

  ![image-20190421111619159](/Users/chenyansong/Documents/note/images/compileStud/40.png)





## DFA的化简问题

​	







