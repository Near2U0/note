[TOC]

# 出现野指针

```c
void main(void)
{
  char *p1 = NULL;
  p1 = (char *)malloc(200);
  if(p1 == NULL)
  {
    return;
  }
  
  strcpy(p1, "11111");
  printf("%s\n", p1);
  
  if(p1 != NULL)//这里只是释放了p1指向的堆内存空间，但是指针变量还是有值的，这就是野指针
    free(p1);
  
  if(p1 != NULL)//这里会error，因为指针变量p1还是有值的，所以并不为NULL，此时释放的是一块未知的内存空间
    free(p1);
  
  return;
}

//正确的做法：在释放指针所指向的空间的时候，还要让指针指向NULL，避免指针变成野指针(建议定义指针的时候定义为NULL，释放内存空间的时候，重置指针为NULL)
void main(void)
{
  char *p1 = NULL;
  p1 = (char *)malloc(200);
  if(p1 == NULL)
  {
    return;
  }
  
  strcpy(p1, "11111");
  printf("%s\n", p1);
  
  if(p1 != NULL)//这里只是释放了p1指向的堆内存空间，但是指针变量还是有值的，这就是野指针
  {
    free(p1);
    p1 = NULL;//OK
  }
  
  if(p1 != NULL)
    free(p1);
  
  return;
}
```



# 指针间接赋值的应用

```c
int getMem(char **myp1, int *mylen1, char **myp2, int *mylen2)
{
  int ret = 0;
  char *tmp1, tmp2;
  
  tmp1 =(char *)malloc(1000);
  strcpy(tmp1, "aaaaa");
  *myp1 = tmp1;
  *mylen1 = strlen(tmp1);
  
  tmp2 = (char *)malloc(2000);
  strcpy(tmp2, "bbbbbb");
  *myp2 = tmp2;
  *mylen2 = strlen(tmp2);
  
  return ret;
}

int main(void)
{
  
  char *p1 = NULL;
  int len1 = 0;
  char *p2 = NULL;
  int len2 = 0;
  
  int ret = 0;
  ret = getMem(&p1, &len1, &p2, &len2);
  if(ret != 0)
  {
    print("funcf getMem() error:%d", ret);
  }
  
  //释放内存空间：因为p1是指向分配的堆内存空间，所以需要释放堆空间
  if(p1 == NULL)
  {
    free(p1);
    p1 = NULL;
  }
  if(p2 == NULL)
  {
    free(p2);
    p2 = NULL;
  }
  return 0;
}
```

# 指针的输入和输出特性

```c
//内存在被调用函数中分配的，那么定义的方法时，有out标识
int getMem(char **myp1/*out*/, int *mylen1/*out*/, char **myp2/*out*/, int *mylen2/*out*/);

char *getMem2(int num)
{
  return (char*)malloc(num);//通过return返回内存的地址
}
```

# 字符串

C语言中的字符串，是以零结尾的

C语言中没有字符串类型，以字符数组来模拟字符串

字符串的内存分配：堆上， 栈上， 全局区

```c
void main(void)
{
  
  //字符数组的初始化
  char buf[] = {'a', 'b', 'c'};//buf不是以0结尾的字符串
  char buf2[100]={'a', 'b', 'c'};//如果字符的个数大于100,编译报错
  //后面没有初始化的字符都为0(数字0)
  
  
  //用字符串初始化字符数组
  char buf3[] = "abcde";//sizeof(buf3);//6 字符串后面还有\0,但是作为字符串应该是4个字节
  
  
  //使用数组和指针操作字符串
  char buf5[100] = "hello";
  //buf5[2];
  char *p = buf5;
  //*(p+5);
  //p[5];
  /**
  []和*p是一样的，只不过是符合程序员的阅读习惯
  */
  
  /**
  为啥将数组名，设计成为常量指针？
  buf = buf+1;
  那么释放内存的时候，就找不到数组内存的首地址，也就不能成功释放所有的数组内存空间
  buf = 0x2222;//error也是错误的
  */
}
```



# 字符串copy函数

```c
void main(void)
{
  char a[] = "i am a student";
  char buf[64];
  
  //字符串拷贝
  int i = 0;
  for(i=0; *(a+i)!='\0'; i++)
  {
    *(buf+i) = *(a+i);
  }
  //0没有copy到buf中
  b[i] = '\0';
  printf("buf=%s\n", buf);
  
  return;
}

//另一种实现的方式
void copy_str(char *from, char *to)
{
  while((*to++ = *from++) != '\0');
}
//简洁的写法
void copy_str2(char *from, char *to)
{
  while((*to++ = *from++));
}

//一般函数中指针作为参数，一般在函数内以一个辅助的指针变量，将形参接过来，不要改变原来指针变量的值，这样函数执行完成之后，原来形参指针的指向的位置，是没有改变的
```



# 项目开发字符模型

```c
void main(void)
{
  //求字符串中abcd出现的次数
  char *p = "abcd111abcd222abcd333";
  
  //strstr(str, str2);//在str中找出str2的位置
  int cnt = 0;
  do
  {
    p = strstr(p, "abcd");
    if(p != NULL)
    {
      cnt++;
      p = p+strlen("abcd");
    }
    else//如果某一次没有找到，那么就直接退出循环
    {
      break;
    }
    
  }while(*p != '\0');
  
  
  return ;
}


//while实现
int get_subStr_cnt(char *p)
{
    //求字符串中abcd出现的次数
  char *p = "abcd111abcd222abcd333";
  int cnt = 0;
  while(p=(strstr(p, "abcd")))
  {
    cnt++;
    p = p+ strlen("abcd");
    if(*p == '\0')
      break;
  }
  
  return cnt;
}
```

自定义函数接口，自定义业务函数 和 main函数必须分开

```c
//要有封装设计的思想
//返回值表示程序的运行结果，然后程序的返回值，我们可以使用指针做函数参数来返回
int getCnt(char *myst/*in*/, const char *sub/*in*/, int *ncount/*out*/)
{
  int ret = 0;
  //增加函数的健壮性
  if(myst==NULL || sub==NULL || ncount==NULL)
    return -1;
  
	//求字符串中abcd出现的次数
  char *p = myst;//接过指针变量，不要改变原来的指针变量
  int cnt = 0;
  while(p=(strstr(p, sub)))
  {
    cnt++;
    p = p+ strlen(sub);
    if(*p == '\0')
      break;
  }
  
  //间接赋值
  *ncount = cnt;
  return ret;
}

int main(void)
{
	//求字符串中abcd出现的次数
  char *p = "abcd111abcd222abcd333";
  int count = 0;
  char sub[] = "abcd";
  
  int ret = getCnt(p, sub, &count);
  if(ret != 0)
  {
    printf("func getCnt(),error");
  }
  
  return 0;
}

```

>
指针的输入特性：在调用函数中分配内存，然后将内存的首地址给被调用函数使用
指针的输出特性：在被调用函数中分配内存，然后通过指针做函数参数，将结果传出来



# 删除字符串两边空格

```c
void main(void)
{
  //求非空格字符串的长度
  char *p = "    abcde    ";
  int i,j = 0;
  i = 0;
  j = strlen(p);
  int ncount = 0;
  
  while( isspace(p[i]) && p[i]!='\0' )
  {
    i++;
  }
    
  while( isspace(p[j]) && p[j]!='\0' )
  {
    j--;
  }
  
  ncount = j-i+1;
  
}


//封装到方法中
void getCnt(char *pstr, int *count)
{
  if(p==NULL || count==NULL)
    return -1;
  
  //求非空格字符串的长度
  char *p = pstr;
  int i,j = 0;
  i = 0;
  j = strlen(p);
  int ncount = 0;
  
  while( isspace(p[i]) && p[i]!='\0' )
  {
    i++;
  }
    
  while( isspace(p[j]) && p[j]!='\0' )
  {
    j--;
  }
  
  *count = j-i+1;
}


//去除字符串的前后空格,不改变原来字符串的内容
int trimSpace(const char *str, char *reStr)
{
  int ret = 0;
  if(str==NULL || reStr==NULL)
  	return -1;
  
  //求非空格字符串的长度
  char *p = pstr;
  int i,j = 0;
  i = 0;
  j = strlen(p);
  int ncount = 0;
  
  while( isspace(p[i]) && p[i]!='\0' )
  {
    i++;
  }
    
  while( isspace(p[j]) && p[j]!='\0' )
  {
    j--;
  }
  
  ncount = j-i+1;
  strcpy(reStr, str+i, ncount);//拷贝到新串
  reStr[ncount] = '\0';//最后加上字符串结尾的标识
  
  return ret;
}

```

# 字符串逆序

```c
char buf[] = "abcd";
int length = strlen(buf);
char *p1 = buf;
char *p2 = buf+length-1;

while(p1<p2)
{
    char c = *p1;
    *p1 = *p2;
    *p2 = c;
    ++p1;
    --p2;
}

//递归实现
//buf="abcd";//入栈的顺序是：a,b,c,d ,那么出栈的顺序为：d,c,b,a
void inversed(char *p)
{
	if(p==NULL)//递归结束的异常条件
        return;
    if(*p =='\0')//递归结束的条件
    	return;
    inversed(p+1);//让abcd的地址入栈
    printf("%c", *p);//出栈打印
}

//将逆序的结果保存下来g_buf
void inversed2(char *p)
{
	if(p==NULL)//递归结束的异常条件
        return;
    if(*p =='\0')//递归结束的条件
    	return;
    inversed(p+1);//让abcd的地址入栈
    strcat(g_buf, *p);//将运算结构拷贝到g_buf
}

char g_buf[100];
int main(void)
{
    char buf[] = "abcd";
    memset(g_buf, 0, sizeof(g_buf));
    inversed2(buf);
}
```







