[toc]

# 出现野指针

```c
void main(void)
{
  char *p1 = NULL;
  p1 = (char *)malloc(200);
  if(p1 == NULL)
  {
    return;
  }
  
  strcpy(p1, "11111");
  printf("%s\n", p1);
  
  if(p1 != NULL)//这里只是释放了p1指向的堆内存空间，但是指针变量还是有值的，这就是野指针
    free(p1);
  
  if(p1 != NULL)//这里会error，因为指针变量p1还是有值的，所以并不为NULL，此时释放的是一块未知的内存空间
    free(p1);
  
  return;
}

//正确的做法：在释放指针所指向的空间的时候，还要让指针指向NULL，避免指针变成野指针(建议定义指针的时候定义为NULL，释放内存空间的时候，重置指针为NULL)
void main(void)
{
  char *p1 = NULL;
  p1 = (char *)malloc(200);
  if(p1 == NULL)
  {
    return;
  }
  
  strcpy(p1, "11111");
  printf("%s\n", p1);
  
  if(p1 != NULL)//这里只是释放了p1指向的堆内存空间，但是指针变量还是有值的，这就是野指针
  {
    free(p1);
    p1 = NULL;//OK
  }
  
  if(p1 != NULL)
    free(p1);
  
  return;
}
```



# 指针间接赋值的应用

```c
int getMem(char **myp1, int *mylen1, char **myp2, int *mylen2)
{
  int ret = 0;
  char *tmp1, tmp2;
  
  tmp1 =(char *)malloc(1000);
  strcpy(tmp1, "aaaaa");
  *myp1 = tmp1;
  *mylen1 = strlen(tmp1);
  
  tmp2 = (char *)malloc(2000);
  strcpy(tmp2, "bbbbbb");
  *myp2 = tmp2;
  *mylen2 = strlen(tmp2);
  
  return ret;
}

int main(void)
{
  
  char *p1 = NULL;
  int len1 = 0;
  char *p2 = NULL;
  int len2 = 0;
  
  int ret = 0;
  ret = getMem(&p1, &len1, &p2, &len2);
  if(ret != 0)
  {
    print("funcf getMem() error:%d", ret);
  }
  
  //释放内存空间：因为p1是指向分配的堆内存空间，所以需要释放堆空间
  if(p1 == NULL)
  {
    free(p1);
    p1 = NULL;
  }
  if(p2 == NULL)
  {
    free(p2);
    p2 = NULL;
  }
  return 0;
}
```

# 指针的输入和输出特性

```c
//内存在被调用函数中分配的，那么定义的方法时，有out标识
int getMem(char **myp1/*out*/, int *mylen1/*out*/, char **myp2/*out*/, int *mylen2/*out*/);

char *getMem2(int num)
{
  return (char*)malloc(num);//通过return返回内存的地址
}
```

# 字符串

C语言中的字符串，是以零结尾的

C语言中没有字符串类型，以字符数组来模拟字符串

字符串的内存分配：堆上， 栈上， 全局区

```c
void main(void)
{
  
  //字符数组的初始化
  char buf[] = {'a', 'b', 'c'};//buf不是以0结尾的字符串
  char buf2[100]={'a', 'b', 'c'};//如果字符的个数大于100,编译报错
  //后面没有初始化的字符都为0(数字0)
  
  
  //用字符串初始化字符数组
  char buf3[] = "abcde";//sizeof(buf3);//6 字符串后面还有\0,但是作为字符串应该是4个字节
  
  
  //使用数组和指针操作字符串
  char buf5[100] = "hello";
  //buf5[2];
  char *p = buf5;
  //*(p+5);
  //p[5];
}
```

