转自：https://blog.csdn.net/KysonLai/article/details/81625797 



# 计算机组成原理-指令系统

[TOC]



本文主要介绍指令的基本格式以及寻址方式：

![](E:/git-workspace/note/images/computermk/jisuanjizucheng.png)




指令其实就是一组有特殊意义的二进制数，指示计算机执行某种操作的命令，也叫机器字或指令字，是计算机运行的最小功能单位。一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。指令系统是计算机的主要属性，位于硬件和软件的交界面上。

指令字长度：一个指令包含的二进制数的位数

机器字长：计算机能直接处理的二进制数的位数，通常与主存单元的位数一致

①指令字长度 = 机器字长度 称为单字长指令

②指令字长度 = 0.5 × 机器字长 称为半字长指令

③指令字长度 = 2 × 机器字长 称为双字长指令

 

## 一、基本格式：

一条指令通常包括操作码和地址码两部分

* **操作码（OP）**指出执行什么操作，如加减乘除、存数、取数等。CPU中有专门电路来解释操作码，从而执行相应的操作。3位操作码最多可表示8条不同的指令
* **地址码（A）**给出数据或者指令的地址

![](E:/git-workspace/note/images/computermk/jisuanjizucheng_zhilingxitong2.png)

根据指令中操作数地址码的数目的不同，可将指令分为以下几种：

### 1.零地址指令：

![](E:/git-workspace/note/images/computermk/jisuanjizucheng_zhilingxitong3.png)

只有操作数，没有地址码，这种指令有两种可能：

①不需要操作数，如停机指令

②零地址的运算类指令仅用在堆栈计算机中，通常参与运算的两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算结果再隐含地压入到堆栈中

### 2.一地址指令：

![](E:/git-workspace/note/images/computermk/jisuanjizucheng_zhilingxitong4.png)

只有一个地址码，有两种可能：

* ①单操作数指令，如自增1.自减1，求反，求补等

  OP(A1) -> (A1)

* ②另一个操作数的地址是隐含的，可约定由ACC（累加器）提供

  （ACC）OP(A1) -> ACC

若指令字长为32位，操作码占8位，地址码占24位，则该指令操作数的直接寻址范围为：

$$
2^{24}=16M
$$


### 3.二地址指令：

![](E:/git-workspace/note/images/computermk/jisuanjizucheng_zhilingxitong5.png)

A1给出目的操作数的地址，A2给出源操作数的地址

​	(A1)OP(A2) -> A1

若指令字长为32位，操作码占8位，2个地址码各占12位，则该指令操作数的直接寻址范围为：
$$
2^{12}=4K
$$


### 4.三地址指令：

![](E:/git-workspace/note/images/computermk/jisuanjizucheng_zhilingxitong6.png)

A1给出目的操作数的地址，A2给出源操作数的地址，A3存放操作结果

​	(A1)OP(A2) -> (A3)

若指令字长为32位，操作码占8位，3个地址码各占8位，则该指令操作数的直接寻址范围为：
$$
2^8=256
$$


### 5.四地址指令：

![](E:/git-workspace/note/images/computermk/jisuanjizucheng_zhilingxitong7.png)

A1给出目的操作数的地址，A2给出源操作数的地址，A3存放操作结果，A4给出下一条将要执行的指令的地址

​	(A1)OP(A2) -> (A3)

若指令字长为32位，操作码占8位，4个地址码各占6位，则该指令操作数的直接寻址范围为：

$$
2^6=64
$$


## 二、寻址方式

> 寻址方式就是寻址指令或操作数有效地址的方式，也就是确定数据地址以及下一条将要执行的指令的地址。因此寻址方式分为指令寻址和数据寻址

### 指令寻址

就是找下一条要执行的指令的地址

* 1.顺序寻址

在内存中按顺序取指令，然后一条一条执行，由程序计数器（PC）来记录顺序

* 2.跳跃寻址

跳跃就是本条指令给出下条指令地址的计算方式，是否跳跃可能受状态寄存器和操作数的控制，跳跃的结果是当前指令修改PC值，下一条指令仍然是通过程序计数器PC给出



### 数据寻址

就是找这个指令的操作数的地址

* 1.隐含寻址

  操作数地址隐含在操作码中，如累加寄存器（AC）

* 2.立即寻址

  操作数就在指令中，取指令的时候就已经拿到了操作数

 ![](E:/git-workspace/note/images/computermk/jisuanjizucheng_zhilingxitong8.png)



* 3.直接寻址

  指令中给出操作数的地址，然后到内存中取操作数

![](E:/git-workspace/note/images/computermk/jisuanjizucheng_zhilingxitong9.png)

* 4.间接寻址

  指令中给出操作数的寻址特征位，再根据这个特征位到内存中取操作数

![](E:/git-workspace/note/images/computermk/jisuanjizucheng_zhilingxitong10.png)

* 5.寄存器寻址

  指令给出操作数的地址，然后到寄存器中取操作数

![](E:/git-workspace/note/images/computermk/jisuanjizucheng_zhilingxitong11.png)

 

* 6.寄存器间接寻址

  指令给出寄存器的地址，然后到寄存器中拿到操作数的地址，然后到内存中取操作数

![](E:/git-workspace/note/images/computermk/jisuanjizucheng_zhilingxitong12.png)

* 7.偏移寻址

①相对寻址

把当前指令的地址存在在PC中，然后用形式地址+PC得到有效地址

②基址寻址

在CPU中用一个寄存器来存储一部分地址，然后再加上指令中的形式地址得到有效地址

③变址寻址

在CPU中用一个寄存器来存储一部分地址（这个地址是变动的），然后再加上指令中的形式地址得到有效地址，如遍历数组，数组下标就可以存储在变址中

* 8.堆栈寻址

  将数据以栈的形式存储在内存或寄存器中，进栈出栈都只在栈顶操作

  寄存器堆栈称为硬堆栈，主存中划分出来的堆栈称为软堆栈



|    寻址方式  |   有效地址   |   访存次数   |
| ---- | ---- | ---- |
|   隐含寻址   |   程序指定   |   0   |
|立即寻址	   | A即是操作数		| 0 |
|直接寻址	   |EA=A		| 1 |
|一次间接寻址	      |EA=(A)	|	2|
|寄存器寻址	        |EA=Ri	|	0|
|寄存器间接一次寻址	EA=(Ri)		|1|
|相对寻址	|EA=(PC)+A		|1|
|基址寻址	|EA=(BR)+A		|1|
|变址寻址	|EA=(IX)+A		|1|



