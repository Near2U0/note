[toc]





1. 序列化修改返回的名字

```python
class Country(models.Model):
    country_id = models.AutoField(primary_key = True)
    country_name = models.CharField(max_length = 128)

    class Meta:
        db_table = 'countries'
        
        
class CountrySerializer(serializers.ModelSerializer):
    name = serializers.CharField(source='country_name')
    id = serializers.CharField(source='country_id')
    class Meta:
        model = Country
        fields = ('id', 'name')

#返回数据如下
 	{
      "data": [
        {
          "id": 1,
          "name": "Afghanistan"
        },
        {
          "id": 2,
          "name": "Aland Islands"
        }
      ]
    }
    
```





2. 关联序列化的问题

   ```python
   # usergroups
   class UserInfoSerializer(serializers.ModelSerializer):
       groups = UserGroupSerializer(many=True, source="usergroups")
   
       class Meta:
           model = User
           fields = ['id', 'username', 'user_zh', 'groups']
   ```

   

3. 关联查询字段序列化

   ```python
   class Index(TimeBase):
       index_name = models.CharField(max_length=50, verbose_name="资源名称", unique=True)
       index_desc = models.CharField(max_length=150, verbose_name="资源描述", null=True)
       index_type = models.ForeignKey('index.IndexType', on_delete=models.CASCADE, verbose_name="资源所属类型")
       index_group = models.ForeignKey('group.Group', on_delete=models.CASCADE, verbose_name="资源所属组")
       index_department_id = models.CharField(max_length=50, null=True, verbose_name="所属部门id")
       index = models.CharField(max_length=50, verbose_name="资源名字en")
       index_disk_space = models.CharField(max_length=50, verbose_name="资源占用的磁盘空间", default=0)
       index_field_map = models.CharField(max_length=500, verbose_name="资源的字段map", null=True)
   
       class Meta:
           db_table = "t_index"
   
       @property
       def group_name(self):
           """查询资源对应的组名称"""
           group_name = self.index_group.group_name
           return group_name
   
       @property
       def type_name(self):
           """查询资源对应的组名称"""
           type_name = self.index_type.type_name
           return type_name
   
       
   ```







TODO list



1. 自动生成项目的requirement文件

   ```shell
   https://blog.csdn.net/pearl8899/article/details/113877334
   
   方法一：整个环境下的安装包都保存到requirements.txt中
   
   pip freeze > requirements.txt
   作用范围：pip的freeze命令保存了保存当前Python环境下所有类库包，包括那些你没有在当前项目中使用的类库。 （如果你没有的virtualenv)
   
   
   方法二：只生成单个项目中的使用到的安装包
   
   pip install pipreqs
   pipreqs .
   作用范围：当前项目使用的类库导出生成为requirements.txt。
   
   使用方法：pipreqs 加上当前路径即可。在导出当前项目使用的类库时，先定位到项目根目录，然后调用 pipreqs ./ --encoding=utf8 命令，该命令避免编码错误，并自动在根目录生成 requirements.txt 文件。
   
   生成的requirements.txt：有点慢，耗时1m多
   ```

   



python的环境venv

