[TOC]

我们在排序之前有如下的约定：

```c
void X_Sort(ElementType A[], int N)
```

* N 是正整数
* 只讨论基于比较的排序（>, = , <有定义）
* 只讨论内部排序（假定排序的数据可以一次性放入内存中）
* 稳定性：任意两个相等的数据，排序前后的相对位置不发生改变
* **没有一种排序是任何情况下都表现最好的**，只有当你的数据具有某种特征的时候，这种算法可能是最好的



# 冒泡排序

在完成一次排序是，最大的数已经放在了最前面，重复上述过程，一次找到第二大的数...

```c
void Bubble_Sort(ElementType A[], int N){
  for(P=N-1; P>=0; P--){
    flag=0;
    for(i=0; i<P; i++){
      if(A[i] > A[i+1]){//一趟冒泡,相等不交换，所以这也符合稳定的说法
        Swap(A[i], A[i+1]);
        flag = 1;//标识发生了交换
      }
      if(flag==0) break;//全程无交换
    }
  }
}
/*
最好的情况：原始的数据已经排好序了：T=O(N)
最坏的情况：原始的数据开始时逆序的，但是希望排序之后是顺序的：T=O(N^2)

冒泡排序相对于其他排序的好处：在数据是链表的时候，也是可以进行的，但是其他排序，对链表是有些困难的
*/
```



# 插入排序

抓一手牌的过程

![image-20190708200058959](/Users/chenyansong/Documents/note/images/data_structure/image-20190708200058959.png)

```c
void Insertion_Sort(ElementType A[], int N){
  for(P=1; P<N; P++){
    Tmp = A[P];//摸下一张牌
    for(i=P; i>0&&A[i-1]>Tmp; i--){//如果相等，位置也是不动，所以插入排序也是稳定的
      A[i] = A[i-1];//移出空位
    }
    A[i]=Tmp;//新牌落位
  }
}

/*
最好的情况：原始的数据已经排好序了,内层循环不需要做：T=O(N)
最坏的情况：原始的数据开始时逆序的，但是希望排序之后是顺序的：T=O(N^2)
*/
```



# 时间复杂度下界

逆序对：对于下标i<j，如果A[i] > A[j]， 则称(i, j)是一对逆序对

问题1：对于序列{34,8,64,51,32,21}使用冒泡排序和插入排序分别需要多少次元素交换才能完成？

答案：都是9次



问题2：对于序列{34,8,64,51,32,21}中有多少逆序对？

![image-20190708201129139](/Users/chenyansong/Documents/note/images/data_structure/image-20190708201129139.png)

* 交换2个相邻元素正好消去1个逆序对
* 插入排序和冒泡排序都是交换相邻元素，所以他们的时间复杂度是相同的
* 时间复杂度：T(N, I) = O(N+I) ;其中I是逆序对的个数
* 如果序列基本有序，则插入排序简单且有效



![image-20190708201628129](/Users/chenyansong/Documents/note/images/data_structure/image-20190708201628129.png)



# 希尔排序

![image-20190708202508619](/Users/chenyansong/Documents/note/images/data_structure/image-20190708202508619.png)

![image-20190708202525221](/Users/chenyansong/Documents/note/images/data_structure/image-20190708202525221.png)

![image-20190708202652071](/Users/chenyansong/Documents/note/images/data_structure/image-20190708202652071.png)

![image-20190708202709774](/Users/chenyansong/Documents/note/images/data_structure/image-20190708202709774.png)





# 选择排序

```c
void Selection_Sort(ElementType A[], int N){
  for(i=0; i<N; i++){
    //从A[i]到A[N-1]中找最小元，并将其位置赋给MinPosition
    MinPosition = ScanForMin(A, i, N-1);
    //将未排序部分的最小元换到有序部分的最后位置
    Swap(A[i], A[MinPosition]);
  }
}
```



上面的选择排序的时间复杂度：T=O(N^2)，其实都是每次需要找到最小元，那么如何快速的找到最小元呢？我们使用**最小堆**





# 堆排序

算法1

1. 首先建立一个最小堆

2. 然后每次从堆中取一个最小元素，这样一次取出的元素就是最小序列

3. 重新将最小序列的数组复制到元素组中

   ![image-20190708204512583](/Users/chenyansong/Documents/note/images/data_structure/image-20190708204512583.png)

> 这个算法，需要一半的空间来放置tmp，同时需要将tmp中的数据复制到原始的数组中（复制需要时间）



算法2

1. 每次都构建一个最大堆

2. 从最大堆中根节点和最后一个元素交换位置，这样最大元素放到了末尾
3. 然后将除去最后一个元素的剩余堆进行最大堆重构
4. 重复上面的步骤

![image-20190708204937700](/Users/chenyansong/Documents/note/images/data_structure/image-20190708204937700.png)





# 归并排序

![image-20190708205801904](/Users/chenyansong/Documents/note/images/data_structure/image-20190708205801904.png)

![image-20190708205818075](/Users/chenyansong/Documents/note/images/data_structure/image-20190708205818075.png)



# 递归算法

先将左边的递归排好序，再将右边递归的排好序，然后对左右两边调用归并算法进行最终的排序

![image-20190708211030103](/Users/chenyansong/Documents/note/images/data_structure/image-20190708211030103.png)

![image-20190708211048684](/Users/chenyansong/Documents/note/images/data_structure/image-20190708211048684.png)

![image-20190708211109761](/Users/chenyansong/Documents/note/images/data_structure/image-20190708211109761.png)



# 非递归算法

第一次排序将1，2元素，3，4元素...,n-1,n元素进行排序，然后在上次排序的结果上，进行新的1，2元素，3，4元素...,n-1,n元素进行排序，一次类推

![image-20190708212502836](/Users/chenyansong/Documents/note/images/data_structure/image-20190708212502836.png)



一次排序程序

![image-20190708212527697](/Users/chenyansong/Documents/note/images/data_structure/image-20190708212527697.png)

整体排序程序

![image-20190708212607197](/Users/chenyansong/Documents/note/images/data_structure/image-20190708212607197.png)

