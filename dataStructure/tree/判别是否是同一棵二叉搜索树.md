[TOC]

# 思路

**给定一个插入序列就可以唯一的确定一棵二叉搜索树，然后，一棵给定的二叉搜索树确可以由多种不同的插入序列得到**，例如，按照序列{2，1，3}和序列{2，3，1}插入初始为空的二叉搜索树，得到一样的结果



* 问题：对于输入的各种插入序列，需要判断他们是否能生成一样的二叉搜索树

  ![image-20190619211016756](https://chenyansong1/note/blob/master/images/data_structure/image-20190619211016756.png?raw=true)



* 比较两棵树是否相同的，求解思路

  * 分别建两棵搜索树，然后一一对比

  * 不建树的方法

    ![image-20190619211830469](https://chenyansong1/note/blob/master/images/data_structure/image-20190619211830469.png?raw=true)

  * 建一棵树，再判断其他序列是否与该树一致

    * 搜索树怎么表示
    * 建搜索树T
    * 判别一序列是否与搜索树T一致

    

# 搜索树的表示

```c
typedef struct TreeNode *Tree;
struct TreeNode{
  int v;//表示节点信息
  Tree Left, Right;
  int flag;//表示节点是否访问过，0未访问过
}
```



# 程序框架

![image-20190619213005124](https://chenyansong1/note/blob/master/images/data_structure/image-20190619213005124.png?raw=true)

```c
int main(){
  int N,L,i;
  Tree T;
  
  scanf("%d", &N);
  //如果输入0表示程序结束
	while(N){
    //有L组序列需要和基础的树，进行比较
    scanf("%d", &L);
    //构建基础树
    T = MakeTree(N);
    
    for(i=0;i<L;i++){
      if(Judge(T,N)) printf("Yes\n");
      else printf("NO\n");
    }
    
    //释放基础树的数据，继续读入下一次比较
    FreeTree(T);
    scanf("%d", %N);
  }
}
```



# 如何建搜索树

```c
Tree MakeTree(int N){
  Tree T;
  int i,V;
  
  scanf("%d", &V);//读入长度为N的第一个，作为根，剩下N-1个元素在for循环中读入
  T = NewNode(V);
 	for(i=1;i<N;i++){//N-1个元素在for循环中读入
    scanf("%d", &V);
    T = Insert(T,V);//依次向根中，插入元素
  }
  
  return T;
}


/*创建树*/
Tree NewNode(int V){
  Tree T = (Tree)malloc(sizeof(struct TreeNode));
  T->v = V;
  T->Left = T->Right=NULL;
  T->flag = 0;
  
  return T;
}

/*向树中插入节点*/
Tree Insert(Tree T, int V){
  if(!T) T=NewNode(V);
  else{
    if(V > T->v)
      T->Right = Insert(T->Right, V);
    else
      T->Left = Insert(T->Left, V);
  }
  return T;
}
```

