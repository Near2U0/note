[TOC]

转自：

https://www.cnblogs.com/hoys/archive/2012/08/19/2646377.html

https://blog.csdn.net/Lycorisradiata__/article/details/80096203

# 1 信号本质（***）

软中断信号（signal，又简称为信号）**用来通知进程发生了异步事件**。**在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的**。信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，**通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。**

 

收到信号的进程对各种信号有不同的处理方法。处理方法可以分为三类：

第一种是类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处理。

第二种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。

第三种方法是，对该信号的处理保留系统的默认值，这种缺省操作，对大部分的信号的缺省操作是使得进程终止。进程通过系统调用signal来指定进程对某个信号的处理行为。

 

# 2 信号的种类

可以从两个不同的分类角度对信号进行分类：

可靠性方面：可靠信号与不可靠信号；

与时间的关系上：实时信号与非实时信号。

 

## 2.1 可靠信号与不可靠信号

Linux信号机制基本上是从Unix系统中继承过来的。早期Unix系统中的信号机制比较简单和原始，信号值小于SIGRTMIN的信号都是不可靠信号。这就是"不可靠信号"的来源。它的主要问题是信号可能丢失。

随着时间的发展，实践证明了有必要对信号的原始机制加以改进和扩充。由于原来定义的信号已有许多应用，不好再做改动，最终只好又新增加了一些信号，并在一开始就把它们定义为可靠信号，这些信号支持排队，不会丢失。

信号值位于SIGRTMIN和SIGRTMAX之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。Linux在支持新版本的信号安装函数sigation()以及信号发送函数sigqueue()的同时，仍然支持早期的signal()信号安装函数，支持信号发送函数kill()。

信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。目前linux中的signal()是通过sigation()函数实现的，因此，即使通过signal()安装的信号，在信号处理函数的结尾也不必再调用一次信号安装函数。同时，由signal()安装的实时信号支持排队，同样不会丢失。

对于目前linux的两个信号安装函数：signal()及sigaction()来说，它们都不能把SIGRTMIN以前的信号变成可靠信号（都不支持排队，仍有可能丢失，仍然是不可靠信号），而且对SIGRTMIN以后的信号都支持排队。这两个函数的最大区别在于，经过sigaction安装的信号都能传递信息给信号处理函数，而经过signal安装的信号不能向信号处理函数传递信息。对于信号发送函数来说也是一样的。

 

## 2.2 实时信号与非实时信号

早期Unix系统只定义了32种信号，前32种信号已经有了预定义值，每个信号有了确定的用途及含义，并且每种信号都有各自的缺省动作。如按键盘的CTRL ^C时，会产生SIGINT信号，对该信号的默认反应就是进程终止。后32个信号表示实时信号，等同于前面阐述的可靠信号。这保证了发送的多个实时信号都被接收。

非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。

 

# 3 信号处理流程

对于一个完整的信号生命周期(从信号发送到相应的处理函数执行完毕)来说，可以分为三个阶段：

信号诞生

信号在进程中注册

信号的执行和注销

# 4 阻塞信号



实际执行信号的处理动作（3种）称为信号递达；
信号从产生到递达之间的状态，叫做信号未决；
进程可以选择阻塞某个信号；
被阻塞的信号产生时，将保持在未决状态，直至进程取消对该信号的阻塞，才执行递达的动作；
注意：**阻塞和忽略是不同的。只要信号阻塞就不会被递达；而忽略是信号在递达之后的一种处理方式**

信号在内核中的表示示意图：

![img](E:\git-workspace\note\images\os\signal.jpg)



每个信号都有两个标志位分别表示阻塞（block）和未决（pending），还有一个函数指针（handler）表示处理动作。信号产生时，内核在进程控制块中设置该信号的未决标志，直至信号递达才清除该标志。操作系统向进程发送信号就是将pending位图中的该信号对应状态位由0变为1。
    如上图，SIGHUP信号未阻塞也未产生过，当它递达时执行默认处理动作；SIGINT信号产生过，但是正在被阻塞，所以暂时递达不了。虽然它的处理动作是忽略，但是未解除阻塞时不能忽略该信号，因为经常仍有机会改变处理动作后再解除阻塞；SIGQUIT信号未产生过，但是它是阻塞的，所以一旦该信号产生它就被阻塞无法递达，它的处理动作也是用户自定义函数。
    在Linux下，如果进程解除某信号的阻塞之前，该信号产生了很多次，它的处理方法是：若是常规信号，在递达之前多次产生只计一次；若是实时信号，在递达之前产生多次则可以放在一个队列里。本文只讨论常规信号，下面提到的信号都是常规信号。

# 5 捕捉信号

在前面的介绍中我们可以知道，当信号的处理动作是自定义函数的时候，在信号递达时就调用这个函数，这称为捕捉信号。内核对信号的捕捉详细过程见下图（进行了四次用户态与内核态的切换）：

![img](E:\git-workspace\note\images\os\signal_get.jpg)

说明：信号处理函数与main函数使用不同的堆栈空间，它们之间不存在调用与被调用的关系，是两个独立的控制流程。










