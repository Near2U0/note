[TOC]

# 指针

  ```c
  int i;
  int* p = &i;
  int* p,q;//p是一个指针；但是q并不是一个指针
  int  *p,q;//p是一个指针；但是q并不是一个指针
  int *p,*q;//p,q都是指针
  ```

  ![image-20190627224101274](/Users/chenyansong/Documents/note/images/c_languge/image-20190627224101274.png)

  > 指针变量的值是内存的地址；普通的变量里面放的就是实际的值

  ```c
  void f(int *p);
  //我们调用的时候
  int i = 0;
  f(&i);//在被调用的时候，得到的是某个变量的地址
  ```

  ![image-20190627224747272](/Users/chenyansong/Documents/note/images/c_languge/image-20190627224747272.png)

  *号是一个单目运算符，用来访问指针的值所表示的地址上的变量

  可以做右值，也可以做左值

  ```c
  int k = *p;
  *p = k+1;
  ```

  ![image-20190627230514072](/Users/chenyansong/Documents/note/images/c_languge/image-20190627230514072.png)

  ```c
  //以下四种函数的原型是等价的
  int sum(int *ar, int n);
  int sum(int *, int);
  int sum(int ar[], int n);
  int sum(int[], int);
  
  ```

  ![image-20190627231432601](/Users/chenyansong/Documents/note/images/c_languge/image-20190627231432601.png)

  ```c
  int b[] --> int * const b;
  //这个数组是一个常量指针，所以就不能赋值，如下
  int a[];
  int b[];
  a = b;//error
  ```

  

# 字符数组

```c
char word[] = {'H', 'e', 'I', 'I', 'o', '!'}
```

![image-20190628194405704](/Users/chenyansong/Documents/note/images/c_languge/image-20190628194405704.png)

# 字符串

```c
char word[] = {'H', 'e', 'I', 'I', 'o', '!', '\0'}
```

* 以0(整数0)结尾的一串字符
* 0或'\0'是一样的，但是和'0'不同
* 0标志字符串的结束，但他不是字符串的一部分
* 计算字符串长度的时候不包含这个0
* **字符串以数组的形式存在**，以数组或指针的形式访问
* 更多的是以指针的形式
* string.h里面有很多处理字符串的函数

```c
char *str = "Hello";
char word[] = "Hello";
char line[10] = "Hello";

/*
"Hello"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有白鸥是结束的0
*/
```

* C语言的字符串是以字符数组的形态存在
* 不能用运算符对字符串做运算
* 通过数组的方式可以遍历字符串



# 字符串变量

```c
int main(void){
  char *s = "Hello,World!";
  char *s2 = "Hello,World!";
  
  printf("s=%p", s);
  printf("s2=%p", s2);
  //打印的结果，我们知道s和s2的地址是相同的
  
  s[0] = 'B';//error
  
  printf("Hello!s[0]=%c\n", s[0]);
}
```

​	![image-20190628200156439](/Users/chenyansong/Documents/note/images/c_languge/image-20190628200156439.png)

> 因为是只读的，所以`s[0] = 'B';//error`

```c
char *s = "Hello, World!";
/*
s是一个指针，初始化为指向一个字符串常量
由于这个常量所在的地方，所有实际上s是const char *s ,但是由于历史的原因，编译器也接收不带const的写法
但是视图对s所指的字符串做写入会导致严重的后果

如果需要修改字符串，应该用数组的方式：
char s[] = "Hello,Word!";
*/
```

![image-20190628200738994](/Users/chenyansong/Documents/note/images/c_languge/image-20190628200738994.png)

	> 我们会发现s3同样是指向的是相同的字符串，但是并没有和s，s2指向的是同一个地址，说明此事s3的地址是一个原来字符串的拷贝



# 指针还是数组

```c
char *st = "Hello";
char word[] = "Hello";
```

* 数组：这个字符串在这里
  * 作为本地变量空间自动被回收
* 指针：这个字符串不知道在哪里
  * 函数处理参数
  * 动态分配空间

> 如果要构造一个字符串，用数组
>
> 如果要处理一个字符串，指针



字符串输入输出

```c
char string[8];
scanf("%s", string);//读入一个单词（到空格，tab，或回车为止）
printf("%s", string);

char buffer[100] = "";
//这是一个空的字符串，buffer[0]='\0'

char buffer[] = "";
//这个数组的长度只有1
```

* scanf读入一个单词（到空格，tab，或回车为止）
* scanf是不安全的，因为不知道要读入的内容长度
* 安全的方式：`scanf("%7s", word);`,7表示最对读入7个字符
* 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小1



# 字符串函数

```c
#include <string.h>

strlen
strcmp
strcpy
strcat
strchr
strstr


size_t strlen(const char *s);
//返回s的字符串长度(不包含结尾的0)

int strcmp(const char *s1, const char *s2);
/*
比较两个字符串，返回
0  s1==s2
>0  s1>s2
<0 s1<s2
*/
//判断前几个字符是否相同
int strncmp(const char *s1, const char *s2, size_t n);

char* strcpy(char *restrict dst, const char *restrict src);
//把src的字符串拷贝到dst
//restrict标明src和dst不重叠
//返回dst,为了能链起代码来


char* strcat(char *restrict s1, const char *restrict s2);
//把s2拷贝到s1的后面，变成一个长的字符串
//返回s1，s1必须具有作足够的空间

//strcpy和strcat都有可能出现安全问题
//如果目的地没有足够的空间
//安全的方式:n指定最多可以操作的字符数
char * strncpy(char *restrict dst, const char *restrict src, size_t n);
char * strncat(char *restrict s1, const char *restrict s2, size_t n);


//字符串中找字符
char* strchr(const char *s, int character);
char* strrchr(const char *s, int c);
//返回NULL，表示没有找到
//找到，返回的是指针，指向找到的字符

```



# 指针的使用









