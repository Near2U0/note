[TOC]



# 指针

指针存放的内容是一个地址，**该地址指向一块内存空间**

计算机的内存最小单位是byte，每一个byte的内存都有一个唯一的编号，这个编号就是内存地址，编号在32位系统下是一个32位的整数，在64位系统下是一个64位整数

```c
int main()
{
    int a = 0;
    printf("%p\n", &a);//打印a变量的地址
    
    //&a就是取变量a的地址
    
    //打印数组地址
    char buf[10];
    printf("%p\n", buf);
    
    
    
    //定义指针指向变量的地址
    int *p = &a;//将a的地址赋值给指针变量p
    //地址虽然是一个整数，但他是一个特殊的整数
    
    int *p1;//定义一个变量，他可以指向一个int的地址
    
	//指针变量的地址的值
    int *p = &a;
    int b = *p;//*p的右值表示a的值
    *p = 100;// *P的左值表示变量a,此时a的值为100
    printf("%d\n", b);
    
    
    return 0;
}

```

![1568939829345](E:\git-workspace\note\images\c_languge\1568939829345.png)

![1568939892060](E:\git-workspace\note\images\c_languge\1568939892060.png)

* 无类型指针

  定义一个指针变量，但不指定他指向具体哪种数据类型，可以通过强制转化将void *转化为其他类型指针，也可以用(void *)将其他类型指针强制转化为void类型指针

  ```c
  void *p;
  
  char c = 0;
  char *p2 = &c;
  
  void *p3;//这个叫无类型指针，这只是一个指针变量，而不指向任何具体的数据类型
  
  printf("%d\n", sizeof(p2));//指针在32位系统下是4个字节，因为他表示的是地址
  printf("%d\n", sizeof(p3));//这个还是4字节，因为他表示的是地址（32位系统下）
  ```

* NULL指针

  ```c
  //NULL是一个宏地址，将其转化为0
  // #define NULL (void *)0
  //NULL在c语言中的定义为 (void *)0
  int *p = NULL;//空指针,没有具体指向任何变量地址的指针叫野指针
  
  int *p3;//p3指向了一个未知地址的值
  *p = 333;//对未知地址进行赋值，这个是有问题的，因为如果碰到指向一个有效地址，代码不会出错，但是如果指向的是一个无效地址，那么一定会出错，程序中要避免这种情况的存在
  ```


# 指针的兼容性

```c
//指针兼容性
char buf[10] = {1,2,3,4,5,6,7,8,9,10};
int *p = buf;
printf("%x\n", *p);
//原则上一定是相同类类型的指针指向相同类型的变量地址，不能用一种类型的指针指向另一种类型的变量地址
```

![image-20190920193904571](/Users/chenyansong/Documents/note/images/c_languge/image-20190920193904571.png)



# 指针常量与指向常量的指针

```c
int a = 10;
int *p = &a;

printf("a=%d\n", a);

//指针常量
const int *p = &a;//p这个指针只能 指向一个常量
*p = 20;//error，不能修改一个常量的值，此时的*p的左值是一个常量
printf("%d\n", *p);//*p是右值，是可读的
//此时p是指向的一个常量，但是并不是p本身是常量，p是可以修改的
int b = 33;
p = &b;//ok
int const *p = &a;//指针常量


//指针常量
int a = 20;
int b = 30;
int *const p = &a;//常量指针
*p = 20;//ok
printf("%d\n", *p);//ok

//但是常量指针不能修改指向
p = &b;//error
```



# 指针和数组

```c
char buf[10] = {0,1,2,3,4};

char *p = buf;
//char *p = &buf;
char *p1 = &buf[0];
char *p2 = &buf[1];
char *p3 = &buf[2];

printf("%d, %d, %d, %d", p, p1, p2, p3);
```

![image-20190920195832564](/Users/chenyansong/Documents/note/images/c_languge/image-20190920195832564.png)

```c
char buf[10] = {0,1,2,3,4};

char *p = buf;
char *p1 = &buf[0];
char *p2 = &buf[1];
char *p3 = &buf[2];

p3 += 1;
*p3 = 100;//buf[3]=100


//使用指针循环赋值buf
for(int i=0; i<10; i++)
{
  *p = i;
  p++;
}
```

IP地址的保存方式，将IP地址转成Int在网络中传递

```c
//"192.168.1.2" = 11个字节
//"1.1.1.1" = 7个字节
//IP地址以int的方式在网络中传递，只需4个字节

//IP地址的保存方式
char buf[] = "192.168.1.2";
//"192.168.1.2"
int ip = 0;
unsigned char *p1 = &ip;
*p1 = 192;
p1++;
*p1 = 168;
p1++;
*p1=1;
p1++;
*p1=2;//对int 类型的ip每一位都赋值一个ip段
printf("%d\n", ip);

//打印IP
void ip2s(int n)
{
  unsigned char *p = &n;
  printf("%u.%u.%u.%u\n", *p, *(p+1), *(p+2), *(p+3));
}


//char buf[] = "192.168.1.2";
int s2ip(char s[])
{
  //得到IP段
  int a = 0;
  int b = 0;
  int c = 0;
  int d = 0;
  
  sscanf(s, "%d.%d.%d.%d", &a, &b, &c , &d);
  
  //将IP段转成整数
  int ip = 0;
  unsigned char *p1 = &ip;
  *p1 = a;
  p1++;
  *p1 = b;
  p1++;
  *p1 = c;
  p1++;
  *p1 = d;//对int 类型的ip每一位都赋值一个ip段
  printf("%d\n", ip);

  return ip;
}
```

# 指针实现计算字符串长度及合并字符串

```c
char s1[100] = "hello";
char s2[100] = "world";

//计算字符串的长度
char *p1 = s1;
int len = 0;
//while(*p1 == '\0')
while(*p1)//*p1的内容为0的时候，表示字符串结束了
{
  p1++;
  len++;
}

//字符串合并
char *p2 = s2;
while(*p2)
{
  *p1 = *p2;//p1从s1的最后开始，从s2的首元素开始
  p2++;
  p1++;
  
  //*p1++ = *p2++;//替代上面三行
}
printf("s1=%s", s1);

```

