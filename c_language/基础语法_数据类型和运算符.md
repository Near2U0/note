[TOC]

# 常量

常量就是在程序中不可变的量，常量在定义的时候就必须定义一个初值

* define

```c
#include <stdio.h>

#define MAX 10  //定义一个宏常量，值为10

int main()
{
    int i;
    i = 100;//定义一个变量，名字为i，值是可以变的
    // MAX = 2000; //error 常量的值不能修改
    printf("%d\n", MAX);
    
    return 0;
}
```

* const

```c
#include <stdio.h>

int main()
{
    const int a = 20; //定义了一个const常量，值为20
  	a = 30;//error 常量的值不能修改
    printf("%d\n", MAX);
    
    return 0;
}
```

* 字符串常量

```c
#include <stdio.h>

#define STRING "hello world\n"  //定义一个字符串常量

int main()
{
    printf(STRING);
 	
    //定义字符串const常量
    const char *str = "hello c";
    return 0;
}
```

> 对于#define类型的常量，c语言的习惯是常量名称为大写，但对于普通类型的常量，使用小写

# 二进制，八进制，16进制

## 二进制

二进制：逢二进一

一个二进制的位只能表示0或者1，两种状态，简称bit

一个字节为8个二进制，称为8位，简称Byte

一个字为2个字节，简称WORD

两个字为双字，简称DWORD

500GB (500GByte)

10Mb  (10Mbit)

## 8进制

八进制：逢八进一

```c
printf("%d", 010);//8进制前面加0，表示8进制
```

## 16进制

逢16进1

```c
0,1,2...,9,a,b,c,d,e,f
printf("%d\n",0x10);//十六进制前加0x,表示16进制
```

## 进制转换

```CQL
#2进制	111		101	 	111
#8进制	

#2进制	0001	1110	1111
#16进制
```



# 原码，补码，反码

为了便于计算，计算机内部都是按照补码进行存储和计算的

| 数字 | 原码      | 反码      | 补码      |
| ---- | --------- | --------- | --------- |
| 7    | 0000 0111 | 0000 0111 | 0000 0111 |
| -7   | 1000 0111 | 1111 1000 | 1111 1001 |

```c
//十六进制输出数据，这样就是是补码输出
//16进制数是二进制的简单表达，所以他不表达负数
printf("%x\n", -10);
printf("%X\n", -10);//用大写输出16进制
printf("%o\n", -10);//用八进制输出，8进制也是表示的二进制的，没有正负之分

//sizeof求指定数据类型在内存中的大小，如果机器是32位，那么输出4byte
printf("%d\n", sizeof(10));
int i = 10
printf("%d\n", sizeof(i));
```



# int，unsigned int 类型

int就是32位的一个二进制整数，在内存中占据4个字节的空间

```c
//输出一个有符号的十进制的整数
printf("%d", 10);
//输出无符号整数,忽略最高位是符号位，正数输出
printf("%u", 10);

//unsigned表示无符号整数，无符号数都是正数；例如8位的有符号数：-128~127，但是如果是无符号数：0~255
unsigned int e = 10;
printf("%d\n", sizeof(e));

unsigned short f;//无符号的short
unsigned long g;//无符号的long
unsigned long long l;//无符号的long long
```





# short,long, long long 

```c
//短整数，在32位系统下是2个字节，16位
short i = 10;
printf("%d\n", sizeof(i));

//长整数，在32位系统下，long都是4字节，在64位系统下，Windows下还是4个字节，Linux下是8个字节，int无论是在32位系统还是64位系统下，都是4个字节
long i = 10;
printf("%d\n", sizeof(i));

//64位，8字节大小的整数,和平台无关，对于32位操作系统，CPU寄存器是32位，所以计算long long的效率很低
long long i = 10;
printf("%d\n", sizeof(i));
```

# 整数溢出

计算一个整数的时候超过整数能够容纳的最大单位后，整数会溢出，结果是：高位舍弃

```c
unsigned short number = 0xffff;
number = number+1;
printf("%d\n", number);
```

# 大端对齐和小端对齐

对于Intel这种x86这种复杂的指令CPU，整数在内存中是倒着存放的，低地址放低位，高地址放高位，这就是小端对齐

但对于Unix服务器的CPU，更多的采用大端对齐的情况

![1568249285203](E:\git-workspace\note\images\c_languge\1568249285203.png)

```c
//内存都是以字节为单位的
int a1 = 0x12345678;
printf("%p\n", &a1);//%p的意思是显示一个内存的地址
printf("%p\n", &a1+1);//%p的意思是显示一个内存的地址
printf("%p\n", &a1+2);//%p的意思是显示一个内存的地址
printf("%p\n", &a1+3);//%p的意思是显示一个内存的地址
```

# char

```c
char ch;
ch = 'a';
printf("%c", ch);

//占用1个字节
printf("%d\n", sizeof(ch));

//ch等于一个整数
ch = 52;
printf("%c", ch);
ch = '4';

//52就是4这个字符的ASCII码
printf("%d", ch);

//char的本质就是只有一个字节大小的整数
```

