[toc]



# 文件完成进程间通信

```c
/* 
 *父子进程共享打开的文件描述符------使用文件完成进程间通信.
 */
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/wait.h>


int main(void)
{
    int fd1, fd2; pid_t pid;
    char buf[1024];
    char *str = "---------test for shared fd in parent child process-----\n";


    pid = fork();
    if (pid < 0) {
        perror("fork error");
        exit(1);
    } else if (pid == 0) {
        fd1 = open("test.txt", O_RDWR);
        if (fd1 < 0) {
            perror("open error");
            exit(1);
        }
        write(fd1, str, strlen(str));
        printf("child wrote over...\n");

    } else {
        fd2 = open("test.txt", O_RDWR);
        if (fd2 < 0) {
            perror("open error");
            exit(1);
        }
        sleep(1);                   //保证子进程写入数据

        int len = read(fd2, buf, sizeof(buf));
        write(STDOUT_FILENO, buf, len);

        wait(NULL);
    }

    return 0;
}
```



# mmap

存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I/O操作。

![image-20191110102347617](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191110102347617.png)

## mmap参数说明

``` c
void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset); 

/**
参数：	
	addr: 建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL
	length：欲创建映射区的大小
	prot：映射区权限PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE
	flags：标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)
		  	MAP_SHARED:  会将映射区所做的操作反映到物理设备（磁盘）上。
		  	MAP_PRIVATE: 映射区所做的修改不会反映到物理设备。
	fd：用来建立映射区的文件描述符
	offset：映射文件的偏移(4k的整数倍)

返回：成功：返回创建的映射区首地址；失败：MAP_FAILED宏

*/
```

mmap创建映射区

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>


int main(void)
{

	char *p = NULL;
	int len, ret;

	int fd = open("mytest.txt", O_CREAT|O_RDWR, 0644);
	if(fd < 0)
	{
		perror("open error:");
		exit(1);
	}

	len = ftruncate(fd, 4);
	if(len < 0)
	{
		perror("ftruncate error:");
		exit(1);
	}
	p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
	if(p == MAP_FAILED)
	{
		perror("mmap error");
		exit(1);
	}

	strcpy(p, "abc");//向映射区写数据

	ret = munmap(p, 4);//关闭映射区
	if(ret == -1)
	{
		perror("munmap error:");
		exit(1);
	}
	close(fd);

	return 0;
}

```











