[toc]

# 信号的概念

## 信号的特性

1. 简单
2. 不能携带大量信息
3. 满足某个特定条件才能发送



A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。

**信号的特质**：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉。

**每个进程收到的所有信号，都是由内核负责发送的，内核处理。**



## 与信号相关的事件和状态

产生信号：

1. 按键产生：ctrl+c, ctrl+z, ctrl+\
2. 系统调用产生，如；kill, raise, abort
3. 软件条件产生，如：定时器alarm
4. 硬件异常产生，如：非法访问内存（段错误），除0（浮点数例外），内存对齐出错（总线错误）
5. 命令产生，如：kill 命令



* 信号的处理方式
  1. 执行默认动作 
  2. 忽略(丢弃) ，此时信号也是已经被处理了
  3. 捕捉(调用户处理函数)



* 信号的状态

  ​      递达：递送并且到达进程。

  ​      未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态  



![image-20191112194254140](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191112194254140.png)



* 未决信号集和阻塞信号集

  Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。

  * 阻塞信号集(信号屏蔽字)： 将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(解除屏蔽后)
  * 未决信号集
    * 信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。 
    * 信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。  

  ![image-20191112194342978](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191112194342978.png)



## 信号四要素

1. 信号名字
2. 信号编号
3. 默认处理动作(跟信号唯一绑定)
4. 信号对应的事件



可以使用kill –l命令查看当前系统可使用的信号有哪些  

![image-20191112195619428](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191112195619428.png)

不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。



可通过man 7 signal查看帮助文档获取。也可查看/usr/src/linux-headers-3.16.0-30/arch/s390/include/uapi/asm/signal.h

![image-20191112200134644](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191112200134644.png)

在标准信号中，有一些信号是有三个“Value”，第一个值通常对alpha和sparc架构有效，中间值针对x86、arm和其他架构，最后一个应用于mips架构。一个‘-’表示在对应架构上尚未定义该信号。 



信号的动作

*  Term：终止进程

*  Ign： 忽略信号 (默认即时对该种信号忽略操作)

*  Core：终止进程，生成Core文件。(查验进程死亡原因， 用于gdb调试)

*  Stop：停止（暂停）进程

*  Cont：继续运行进程



注意从man 7 signal帮助文档中可看到 : The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.

这里特别强调了**9) SIGKILL** **和19) SIGSTOP**信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞，(9号默认动作是终止进程；19号默认动作是暂停信号)。

**另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达)，不应乱发信号！！**

![image-20191112201543095](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191112201543095.png) 

## 常规信号

```shell
1) SIGHUP: 当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程
2) SIGINT：当用户按下了<Ctrl+C>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动
作为终止进程。
3) SIGQUIT：当用户按下<ctrl+\>组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信
号。默认动作为终止进程。
4) SIGILL：CPU检测到某进程执行了非法指令。默认动作为终止进程并产生core文件
5) SIGTRAP：该信号由断点指令或其他 trap指令产生。默认动作为终止里程 并产生core文件。
6) SIGABRT: 调用abort函数时产生该信号。默认动作为终止进程并产生core文件。
7) SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件。
8) SIGFPE：在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件。
9) SIGKILL：无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法。
10) SIGUSE1：用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。
11) SIGSEGV：指示进程进行了无效内存访问。默认动作为终止进程并产生core文件。
12) SIGUSR2：另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。
13) SIGPIPE：Broken pipe向一个没有读端的管道写数据。默认动作为终止进程。
14) SIGALRM: 定时器超时，超时的时间 由系统调用alarm设置。默认动作为终止进程。
15) SIGTERM：程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号。默认动作为终止进程。
16) SIGSTKFLT：Linux早期版本出现的信号，现仍保留向后兼容。默认动作为终止进程。
17) SIGCHLD：子进程结束时，父进程会收到这个信号。默认动作为忽略这个信号。
18) SIGCONT：如果进程已停止，则使其继续运行。默认动作为继续/忽略。
19) SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为暂停进程。
20) SIGTSTP：停止终端交互进程的运行。按下<ctrl+z>组合键时发出这个信号。默认动作为暂停进程。
21) SIGTTIN：后台进程读终端控制台。默认动作为暂停进程。
22) SIGTTOU: 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。
23) SIGURG：套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达，默认动作为忽略该信号。
24) SIGXCPU：进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程。默认动作为终止进程。
25) SIGXFSZ：超过文件的最大长度设置。默认动作为终止进程。
26) SIGVTALRM：虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间。默认动作为终止进程。
27) SGIPROF：类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间。默认动作为终止进程。
28) SIGWINCH：窗口变化大小时发出。默认动作为忽略该信号。
29) SIGIO：此信号向进程指示发出了一个异步IO事件。默认动作为忽略。
30) SIGPWR：关机。默认动作为终止进程。
31) SIGSYS：无效的系统调用。默认动作为终止进程并产生core文件。
34) SIGRTMIN ～ (64) SIGRTMAX：LINUX的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时信号的默认动作都为终止进程。
```



#信号的产生

## 终端按键信号

![image-20191112202333595](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191112202333595.png)

## 硬件异常产生信号

![](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191112202411193.png)



## kill命令

```shell
kill -9 1922  #发送9号信号
kill -19 1922 #信号

#kill函数,给指定进程发送指定信号(不一定杀死)
int kill(pid_t pid, int sig);
#sig：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。
#pid=0   
#返回值：0成功；-1返回失败 perror打印
#pid > 0: 发送信号给指定的进程。
#pid = 0: 发送信号给 与调用kill函数进程属于同一进程组的所有进程。
#pid < 0: 取|pid|发给对应进程组。
#pid = -1：发送给进程有权限发送的系统中所有进程。

#成功：0；失败：-1 (ID非法，信号非法，普通用户杀init进程等权级问题)，设置errno
```

```c
#include <signal.h>
int main()
{
	//自杀
	int ret = kill(getpid(), SIGKILL);
	if(ret == -1)
		exit(1);
}
```

创建5个子进程，父进程杀死2号子进程

```c
#include <signal.h>
int main()
{
	int i;
  pid_t pid, q;
  for(i=0; i<5; i++)
  {
    pid = fork();
    if(pid == 0)
      break;
    if(i == 2)
    	q = pid;
  }
  if(i<5)
  {
    while(1)
    {
      printf("I am child %d, getpid= %u\n", i, getpid());
      sleep(1);
    }
  }
  else
  {
    kill(q, SIGKILL);
  }
}
```

* 进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。

* 权限保护：super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。 kill -9 (root用户的pid) 是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发送信号。普通用户基本规则是：发送者实际或有效用户ID == 接收者实际或有效用户ID

## raise,abort函数

raise 函数：给当前进程发送指定信号(自己给自己发) 

```c
//raise(signo) == kill(getpid(), signo);
int raise(int sig); 
//成功：0，失败非0值

```

abort 函数：给自己发送异常终止信号 6) SIGABRT 信号，终止并产生core文件

```c
void abort(void); 
//该函数无返回
```



## alarm函数

4：00





alarm 函数

setitemer函数

# 信号集操作函数

信号屏蔽字

未决信号集





# 信号的捕捉

如何注册信号捕捉函数

sigaction函数（重点）



