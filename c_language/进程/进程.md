[TOC]

# 程序和进程

程序：指编译好的二进制文件，在磁盘上，不占用系统资源（CPU，内存，打开的文件，设备，锁...）

进程：一个抽象的概念，与操作系统相关，进程是活跃的程序，占用系统资源，在内存中执行（程序运行起来就产生了进程）

# 中央处理器的简易架构

![1572914047266](E:\git-workspace\note\images\c_languge\process\1572914047266.png)

# MMU

![](E:\git-workspace\note\images\c_languge\process\02_MMU.png)

![](E:\git-workspace\note\images\c_languge\process\1572914414667.png)

虚拟地址：可用的地址空间有4G（32位），也就是地址在取名的时候可以到4G大小，MMU会完成虚拟地址和物理内存地址的映射



# PCB进程描述符

​         我们知道，每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体  

/usr/src/linux-headers-3.16.0-30/include/linux/sched.h文件中可以查看struct task_struct 结构体定义。其内部成员有很多，我们重点掌握以下部分即可：

* 进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。

* 进程的状态，有就绪、运行、挂起、停止等状态。

  ![](/Users/chenyansong/Documents/note/images/c_languge/image-20191105190903084.png)

* 进程切换时需要保存和恢复的一些CPU寄存器的数据。

* 描述虚拟地址空间的信息。

* 描述控制终端的信息(ptty)。

* 当前工作目录（Current Working Directory）。

* umask掩码。

* 文件描述符表，包含很多指向file结构体的指针。

* 和信号相关的信息。

* 用户id和组id。

* 会话（Session）和进程组。

* 进程可以使用的资源上限（ulimit -a）

  ```shell
  chenyanongdeMBP:进程 chenyansong$ ulimit -a
  core file size          (blocks, -c) 0
  data seg size           (kbytes, -d) unlimited
  file size               (blocks, -f) unlimited
  max locked memory       (kbytes, -l) unlimited
  max memory size         (kbytes, -m) unlimited
  #最大打开的文件数量
  open files                      (-n) 256
  pipe size            (512 bytes, -p) 1
  #栈大小
  stack size              (kbytes, -s) 8192
  cpu time               (seconds, -t) unlimited
  max user processes              (-u) 709
  virtual memory          (kbytes, -v) unlimited
  chenyanongdeMBP:进程 chenyansong$ 
  ```

  

# 环境变量

每个用户都会有自己所属的环境变量，环境变量具有以下特征：

* 字符串
* 有统一的格式： 名=值[:值]
* **值**用来描述进程环境信息



## 常见的环境变量

### PATH

**可执行文件的搜索路径**。ls命令也是一个程序，执行它不需要提供完整的路径名/bin/ls，然而通常我们执行当前目录下的程序a.out却需要提供完整的路径名./a.out，这是因为PATH环境变量的值里面包含了ls命令所在的目录/bin，却不包含a.out所在的目录。PATH环境变量的值可以包含多个目录，用:号隔开。在Shell中用echo命令可以查看这个环境变量的值：

```shell
$ echo $PATH
```

## 打印所有的环境变量

```c
#include <stdio.h>

extern char ** environ;//environ名字固定了

int main(void)
{
  int i;
  for(i=0; environ[i]!=NULL; i++)
  {
    printf("%s\n", environ[i]);
  }
  
  return 0;
}

```

## 环境变量函数

```c
getenv
//获取环境变量值
    char *getenv(const char *name); 	
//成功：返回环境变量的值；失败：NULL (name不存在)

setenv
//设置环境变量的值	
    int setenv(const char *name, const char *value, int overwrite);  	
//成功：0；失败：-1; 参数overwrite取值：	1：覆盖原环境变量 0：不覆盖。(该参数常用于设置新环境变量，如：ABC = haha-day-night)

unsetenv
//删除环境变量name的定义
    int unsetenv(const char *name); 	
//成功：0；失败：-1 注意事项：name不存在仍返回0(成功)，当name命名为"ABC="时则会出错
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void)
{
	char *val;
	const char *name = "ABD";

	val = getenv(name);
	printf("1, %s = %s\n", name, val);

	setenv(name, "haha-day-and-night", 1);

	val = getenv(name);
	printf("2, %s = %s\n", name, val);

#if 1
  //int ret = unsetenv("ABDdfsfs");//name不存在仍返回0(成功)
	int ret = unsetenv("ABD=");//-1
  printf("ret = %d\n", ret);

	val = getenv(name);
	printf("3, %s = %s\n", name, val);

#else
	int ret = unsetenv("ABD");  //name=value:value
	printf("ret = %d\n", ret);

	val = getenv(name);
	printf("3, %s = %s\n", name, val);

#endif

	return 0;
}

```

# 进程控制

创建一个子进程

![image-20191105200427743](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191105200427743.png)

```c

pid_t fork(void);	

/**
失败返回-1；
成功返回：1.父进程返回子进程的ID(非负)	2.子进程返回 0 
pid_t类型表示进程ID，但为了表示-1，它是有符号整型。(0不是有效进程ID，init最小，为1)
	注意返回值，不是fork函数能返回两个值，而是fork后，fork函数变为两个，父子需【各自】返回一个。
*/

```

## 创建单个进程

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int var = 34;

int main(void)
{
    pid_t pid;

    pid = fork();
    if (pid == -1 ) {//创建进程失败
        perror("fork");
        exit(1);
    } else if (pid > 0) {
        sleep(2);
        var = 55;
        printf("I'm parent pid = %d, parentID = %d, var = %d\n", getpid(), getppid(), var);//getpid获取进程ID， getppid获取父进程的ID
      	sleep(2);//让子进程先结束
      
    } else if (pid == 0) {//这里执行的是子进程的逻辑
        var = 100;
        printf("child  pid = %d, parentID=%d, var = %d\n", getpid(), getppid(), var);
    }
  
    printf("var = %d\n", var);

    return 0;
}
```

![](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191105201838512.png)

![](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191105202013024.png)

> 可以看到父进程的父进程是bash



## 创建N个子进程

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>


int main(void)
{
    int i;
    pid_t pid;
    printf("xxxxxxxxxxx\n");

    for (i = 0; i < 5; i++) {
        pid = fork();
        if (pid == 0) {
            break;
        }
    }

    if (i < 5) {
        sleep(i);
        printf("I'am %d child , pid = %u\n", i+1, getpid());

    } else  {
        sleep(i);
        printf("I'm parent\n");
    }

    return 0;
}

```

![](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191105203822865.png)

一次fork函数调用可以创建一个子进程。那么创建N个子进程应该怎样实现呢？

简单想，for(i = 0; i < n; i++) { fork() } 即可。但这样创建的是N个子进程吗？

![image-20191105202822923](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191105202822923.png)

> 从上图我们可以很清晰的看到，当n为3时候，循环创建了(2^n)-1个子进程，而不是N的子进程。需要在循环的过程，保证子进程不再执行fork ，因此当(fork() == 0)时，子进程应该立即break;才正确。

![image-20191105203348006](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191105203348006.png)

> 这样**所有的子进程都是从最初的父进程a.out出来**的，并没有子进程创建子进程的情况

如果去掉其中的sleep，那么就会出现进程随机结束的情况，这其中又有shell进程的存在

![image-20191105204927811](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191105204927811.png)



## 父子进程共享

父子进程之间在fork后。有哪些相同，那些相异之处呢？

刚fork之后：

* 父子相同处: 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式...(**这些数据对父子进程来说是一样的，但是并不是说他们是共享一份，而是子进程对父进程的数据的拷贝**)

* 父子不同处: 1.进程ID  2.fork返回值  3.父进程ID  4.进程运行时间  5.闹钟(定时器)  6.未决信号集

似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？

当然不是! 

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int a = 100;            //.data 

int main(void)
{
	pid_t pid;
	pid = fork();

	if(pid == 0){	//son
		a = 2000;
		printf("child, a = %d\n", a);
	} else {
		sleep(1);	//保证son先运行
		printf("parent, a = %d\n", a);
	}

	return 0;
}

```



