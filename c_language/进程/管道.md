[TOC]

Linux环境下，进程地址空间相互独立，**每个进程各自有不同的用户地址空间**。任何一个进程的全局变量在另一个进程中都看不到，所以**进程和进程之间不能相互访问**，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）

![image-20191107190812375](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191107190812375.png)



现今常用的进程间通信方式有：

1. 管道 (使用最简单)        
2. 信号 (开销最小)
3. 共享映射区(内存) (无血缘关系)
4. 本地套接字 (最稳定)







常见的通信方式有: 单工通信、半双工通信、全双工通信



## 管道

查看管道的默认大小：4k(512byte是一个扇区，他用了8个扇区，就是4k)

![image-20191107192007555](/Users/chenyansong/Documents/note/images/c_languge/process/image-20191107192007555.png)

管道是一种最基本的IPC机制，作用于**有血缘关系**的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：

1. 其本质是一个伪文件(实为内核缓冲区) 
2. 由两个文件描述符引用，一个表示读端，一个表示写端
3. 规定数据从管道的写端流入管道，从读端流出。

管道的原理: **管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。**

管道的局限性：

1. 数据自己读不能自己写。

2. 数据一旦被读走，便不在管道中存在，不可反复读取。

3. 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。

4. 只能在有公共祖先的进程间使用管道。

常见的通信方式有，单工通信、半双工通信、全双工通信

创建管道

```c
int pipe(int pipefd[2]);
// 成功：0；失败：-1，设置errno

```

函数调用成功返回r/w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。

管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？通常可以采用如下步骤：

![1573173711418](E:\git-workspace\note\images\c_languge\process\1573173711418.png)

1. 父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。

2. 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。

3. 父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。

练习：父子进程使用管道通信，父写入字符串，子进程读出并，打印到屏幕

```c
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/wait.h>

void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

int main(void)
{
    pid_t pid;
    char buf[1024];
    int fd[2];
    char *p = "test for pipe\n";
    
   if (pipe(fd) == -1) 
       sys_err("pipe");

   pid = fork();
   if (pid < 0) {
       sys_err("fork err");
   } else if (pid == 0) {
        close(fd[1]);
        int len = read(fd[0], buf, sizeof(buf));
        write(STDOUT_FILENO, buf, len);
        close(fd[0]);
   } else {
       close(fd[0]);
       write(fd[1], p, strlen(p));
       wait(NULL);
       close(fd[1]);
   }
    
    return 0;
}
```

> 为甚么，程序中没有使用sleep函数，但依然能保证子进程运行时一定会读到数据呢？

