[TOC]

# 文件操作

## 写文件

```c
#include <stdio.h>

int main1(void)
{
  //操作一个文件的步骤
  FILE *p = fopen("/tmp/test.txt", "w");//用写的方式打开文件
  //"w":如果文件不存在就创建，如果文件存在就覆盖
  fputs("hello world", p);//向文件中写入字符串
  fclose(p);//关闭这个文件
  
  printf("hello world\n");
}

#include <string.h>

int main(void)
{
  char s[1024] = {0};
  //操作一个文件的步骤
  FILE *p = fopen("/tmp/test.txt", "w");//用写的方式打开文件
  while(1)
  {
    memset(s, 0, sizeof(s));
    //scanf("%s", s);
    gets(s);//可以接受空格
    if(strcmp(s, "exit")==0)//退出循环
      break;
    
    //加上回车换行
    int len = strlen(s);
    s[len] = '\n';
    
    fputs(s, p);//向文件中写入字符串
  }
  fclose(p);//关闭这个文件
  
  printf("hello world\n");
}
```

![image-20190928152050305](/Users/chenyansong/Documents/note/images/c_languge/image-20190928152050305.png)

## 读文件

```c
int main(void)
{
  char s[1024] = {0};
  FILE *p = fopen("/tmp/test.txt", "r");
  /*
  第一个参数：一个内存地址
  第二个参数：这块内存的大小；byte
  第三个参数：fopen返回的文件指针
  */
  //feof(p);//如果已经到了文件结尾，函数返回真
  while(!feof(p))//如果没有到文件结尾，就一直循环
  {
    memset(s, 0, sizeof(s));//清空
    fgets(s, sizeof(s), p);//只能读取一行
    printf("%s\n", s);
  }
  
  fclose(p);//关闭文件
}
```

## 文本文件加密

```c
//加密
void code(char *s)
{
  while(*s)
  {
    (*s)++;//将字符串的字符加1
    s++;
  }
}

//解密
void decode(char *s)
{
  while(*s)
  {
    (*s)--;
    s++;
  }
}

int main(void)
{
  char s[1024] = {0};
  FILE *p = fopen("/tmp/test.txt", "r");
  FILE *p1 = fopen("/tmp/test_w.txt", "w");
  
  /*
  第一个参数：一个内存地址
  第二个参数：这块内存的大小；byte
  第三个参数：fopen返回的文件指针
  */
  //feof(p);//如果已经到了文件结尾，函数返回真
  while(!feof(p))//如果没有到文件结尾，就一直循环
  {
    memset(s, 0, sizeof(s));//清空
    fgets(s, sizeof(s), p);//只能读取一行
    code(s);//加密
    fputs(s, p1);
  }
  
  fclose(p);//关闭文件
  fclose(p1);//关闭文件
}
```

## 二进制和文本模式的区别

![](/Users/chenyansong/Documents/note/images/c_languge/image-20190928162315434.png)

```c
/*
在Windows下以 rb+ 方式读写文件，是'\n'，不会转换为'\r\n'，他只是转成'\n',但是还是在windows下以 r+ 方式读写文件，是 '\n' 会转化为 '\r\n'
*/
```





## 文件打开的方式

```c
/*
r：以只读方式打开，该文件必须存在
r+:以可读写方式打开文件，该文件必须存在
rb+:读写打开一个二进制文件，允许读写数据，文件必须存在
rw+:读写打开一个文本文件，允许读写
w:打开一个只写文件，若文件存在则文件长度清0，即文件内容会消失，若文件不存在则创建该文件
w+:打开可读写文件，若文件存在则文件长度清0，即该文件内容会消失，若文件不存在则创建该文件
a:以附加的方式打开只写文件，若文件不存在，就创建文件，存在，就追加(原来的EOF符保留)
a+:以附加的方式打开可读写文件，若文件不存在，就创建文件，存在，就追加(原来的EOF符不保留)
*/
```

```c
//如果文件打开成功，那么fopen返回打开文件的指针
//打开失败，返回NULL，失败的有可能是：1.文件不存在，2.你没有读写文件的权限
FILE *p = fopen("/tmp/xx.txt", "r");
if(p==NULL)
{
  printf("file open fail\n");
}else
{
  printf("file open success\n");
  fclose(p);//关闭
}
```

```c
int main(void)
{
  FILE *p = fopen("/tmp/xx.txt", "a");//用追加的方式打开文件
  if(p==NULL)
  {
    printf("file open fail\n");
  }else
  {
    fputs("hello", p);
    fclose(p);//关闭
  }
}
```





## 文件读写与追加综合操作

读写字符getc, putc

```c
//getc 
int main(void)
{
  FILE *p = fopen("/tmp/test.txt", "r");
  if(p==NULL)
  {
    printf("file open fail\n");
  }else
  {
    char c = 0;
    while(c != EOF)//EOF代表文件最后的结束标识
    {
      c = getc(p);//一次只读取一个字符
      printf("%c", c);
    }
    /*简化写法
    while((c=getc(p)) != EOF)//EOF代表文件最后的结束标识
    {
      printf("%c", c);
    }
    
    */
    
    fclose(p);//关闭
  }
  
  return 0;
}


//putc
int main(void)
{
  FILE *p = fopen("/tmp/test.txt", "w");
  if(p==NULL)
  {
    printf("file open fail\n");
  }else
  {
    char c = 0;
    putc('a', p);//一次写一个字符
    
    fclose(p);//关闭
  }
  
  return 0;
}

```

## EOF与feof函数文件结尾

EOF代表文件结尾，getc使用

feof函数返回true，标识文件结尾，fgets使用

## 文本文件排序

```c
void swap(int *a, int *b);
//冒泡排序
void puppple(int *p, int n)
{
    int i;
    int j;
    for(i=0; i<n; i++)
    {
        for(j=0; j<n-i; j++)
        {
            if(p[j-1] > p[j])
            {
                swap(&p[j-1], &p[j]);
            }
        }
    }
}

int main(void){
    
    //int array[10] = {1, 3, 2, 5, 9, 10, 7, 11, 9, 10}
    //puppple(array, 10);

    int array[10] = {0};
    char buf[100];
    int index = 0;//计数
    
    FILE *p = fopen("/tmp/text.txt", "r");
    if(p==NULL)
    {
        printf("open fail \n");
    }
    else
    {
        
        while(!feof(p))
        {
            memset(buf, 0, sizeof(buf));//每次读取文件之前，清空
            fgets(buf， sizeof(buf), p);  
            //将读取到的数放入数组
            array[index] = atoi(buf);//str转成int
            index++;
        }
        
		fclose(p);
    }
    
    //对数组元素排序
    puppple(array, index);
    
    p = fopen("/tmp/b.txt", "w");
    int i;
    for(i=0; i<index; i++)
    {
        memset(buf, 0, sizeof(buf));
        sprintf(buf, "%d\n", array[i]);//将数组的成员转化为字符串，存入buf
        fputs(buf, p);
    }
    
    fclose(p);
    return 0;
}
//上面的代码，有一个问题：会依赖定义数组的大小，如果文件的行数超过数组定义的大小，那么数组下标会越界
```

使用动态数组的方式

```c
//在堆中建立数组，对文件进行排序
int main()
{
    //读取文件有多少行
    FILE *p = fopen("/tmp/text.txt", "r");
   	int lincnt = readLineCnt(p);
    
	//动态的创建数组
    int *array = calloc(sizeof(int), lincnt);
    //还是执行上面的逻辑
    
}
```

## 文件内容解析

```c
//不使用sscanf函数


```

