[TOC]

# 数组

C 语言中不会检查数组下标是否越界，如果越界也是打印越界内存中的数据

```c
char s[5];
s[5] = 6;//越界，但是C语言不会帮你进行检查

//一个好的习惯，定义变量的时候，要将变量初始化
//数组维数越多，代码的可读性越差

//字符串一定是以0结尾的char数组
char s[3] = {0};
s[0] = 'a';
s[1] = 'b';
s[2] = 'c';
printf("%s\n", s);
```

![1568595694401](E:\git-workspace\note\images\c_languge\1568595694401.png)

编译之后，每次执行的结果都不一样

![1568595737600](E:\git-workspace\note\images\c_languge\1568595737600.png)

但是如果最后留一位不赋值，那么结果如下

![1568595897808](E:\git-workspace\note\images\c_languge\1568595897808.png)

![1568595882455](E:\git-workspace\note\images\c_languge\1568595882455.png)

结果分析：导致的原因是字符串要以0结尾，但是如果将s[3]的所有位都进行了赋值，那么该字符串就不会是以0结尾的，但是打印的时候是打印%s，所以需要找到0处才会结束，所以每次都是在找到0处结束，但是如果只是赋值s[3]的两位，那么就是确定以0结尾，此时打印的结果就会确定了

```c
char arr[] = "hello\n";//没有指定数组的维数，那么C语言编译器会根据字符串的长度自动填写
char arr1[10] = "hello\n";
```



# 汉字逆置

```c
char buf[100] = "hello world";
int len = 0;
while(buf[len++]);
len--;//得到字符串有效长度
printf("%d\n", len);


// 字符逆置
int min = 0;
int max = len-1;
while(min<max)
{
  char tmp = buf[min];
  buf[min] = buf[max];
  buf[max] = tmp;
  min++;
  max--;
}
printf("%s\n", buf);
```

```c
//如果是中文
char buf[100] = "你好，世界";
int len = 0;
while(buf[len++]);
len--;//得到字符串有效长度
printf("%d\n", len);


// 字符逆置
int min = 0;
int max = len-1;
while(min<max)
{
  char tmp = buf[min];
  buf[min] = buf[max];
  buf[max] = tmp;
  min++;
  max--;
}
printf("%s\n", buf);//此时会出现中文乱码

/*
ASCII：一个字节存放一个字符
GBK：用两个字节存放一个汉字
UTF8:使用3个字节存放一个汉字
*/
while(min<max)
{
  char tmp = buf[min];
  buf[min] = buf[max-1];
  buf[max-1] = tmp;
  
  tmp = buf[min+1];
  buf[min+1] = buf[max];
  buf[max] = tmp;
  
  min += 2;
  max -= 2;
}
/**
如果将一个字符串当做char处理，
那么标准的ASCII字符一定是一个正数，
汉字的第一个字节一定是一个负数
*/
char buf[100] = "你好世界";
printf("%d", buf[0]);//负数

char buf[100] = "a你好世界";
printf("%d", buf[0]);//正数
```



# 混合统计汉字和ASSIC字符串的字符数量

```c
//混合统计汉字和ASSIC字符串的字符数量
char buf[100] = "你好abc";
int len = 0;
int i = 0;
while(buf[i])
{
  if(buf[len]<0)
    i++;
  i++;//实现往前走
  len++;//正常计数
}
printf("%d", len);
```

# 去掉字符串空格

去掉后面的空格

```c
char s[100] = "hello world";
s[4] = 0;
printf("%s\n", s);//hell
s[11] = 'a';
printf("%s\n", s);//hello worlda


char s[100] = "hello world     ";
printf("(%s)\n", s);//(hello world     )

while(s[len++]);
len--;

//去掉空格
for(int i=len-1; i>=0; i--)//s[len]=0；len-1是最后一位空格
{
  if(s[i] != ' ')
  {
    s[i+1] = 0;
    break;
  }
}
printf("%s", s);
```

去掉前面的空格

```c
//1.要知道有几个空格
//2.将非空格字符往前移动n个空格的位
//3.去掉最后的len位，赋0即可解决

char s[100] = " hello";
int len = 0;
while(s[len++] == ' ');
len--;//得到字符串前面的空格数量
printf("%d\n", len);

//字符向前移动len位
int i = len;
while(s[i])
{
  s[i-len] = s[i];
  i++;
}

printf("%s\n", s);
//3.去掉最后的len位，赋0即可解决
s[i-len] = 0;//结束字符串

```





