[TOC]

# 作用域

代码块作用域

```c
int main(void)
{
  int a = 10;
  a = 1;
  {
    int a = 100;
  }
  
  printf("%d\n", a);//1
}
```

全局作用域

```c
int a = 200;//全局变量
int main(void)
{
  int a = 10;
  a = 1;
  {
    int a = 100;
  }
  
  printf("%d\n", a);//1
}
```

文件中定义变量

```c
//vi a.c
int a = 10;

//vi main.c
extern int a;//有一个int类型的变量，名字为age，已经在其他文件中定义了，这里可以直接使用
void set_age(int n)
{
  age = n;
}
void get_age()
{
  printf("%d\n", age);
}
int main(void)
{
  set_age(10);
  get_age();
}
```

auto自动变量

```c
auto int a = 0;//
int a = 0;//不写auto，C语言默认变量都是auto，signed
//自动变量，不需要关心变量在内存中什么时候创建和释放，由编译器解决
```

register寄存器变量

```c
/**
通常变量在内存当中，如果能把变量放到CPU的寄存器中，代码的执行效率会更高
*/
register int i = 0;//建议：如果有寄存器空闲，那么这个变量将放入寄存器中
//int *p = &i;//error，因为指针中存放的是内存地址，但是寄存器是没有内存地址的，所以对于一个寄存器变量是不能取地址的
```

静态局部变量

```c
void mystatic()
{
  static int i = 0;//这句话只会执行一次，不管函数调用多少次
  printf("%d", i);//静态变量，只初始化一次，并且程序运行期间，静态变量一直存在
  i++;
}
int main(void)
{
  int i = 0;
  for(;i<10;i++)
  {
    mystatic();
  }
}
```

![image-20190924231249189](/Users/chenyansong/Documents/note/images/c_languge/image-20190924231249189.png)

静态全局变量

```c
static int a = 20;//静态全局变量


```

静态函数

```c
//此函数只能在该文件中使用
static void test()
{
    int a = 2;
}

//默认情况下，此函数是全局的
void test()
{
    int a = 2;
}
```

调用其他文件的函数

```c
//vim a.c
void test2()
{
    int a = 2;
}

//============================
//vim main.c
void test2();//声明
//extern void test2();//等价声明

/*
extern int age;//1个含义，声明一个变量，此时变量一定已经定义了
int age;//2个含义：1.声明一个变量（如果已经定义了一个变量）；2.定义一个变量
*/
int main()
{
    test2();//调用
    
    return 0;
}
```

# 内存四区

## 代码区，静态区，堆区，栈区介绍

```c
/**
代码区：程序被操作系统加载到内存的时候，所有的可执行代码都被加载到代码区，也叫代码段（指令），这块内存是不可以在运行期间修改的

静态区：静态变量和全局变量

堆区：heap和栈一样，也是在程序运行过程中可以随时修改的内存区域，但是没有栈那样先进后出的顺序
//堆是一个大容器，他的容量要远远大于栈，但是在C语言中，堆内存空间的申请和释放是需要手动通过代码来完成的

栈区：stack是一种先进后出的内存结构，所有的自动变量，函数的形参都是由编译器自动放出栈中，当一个自动变量超出其作用域时，自动从栈中弹出
//对于自动变量，什么时候入栈，什么时候出栈，是不需要程序控制的，由C语言编译器实现
//栈不会很大，一般都是以K单位的
//栈溢出：当栈空间已满，但是还在往栈内存压保留，这就叫做栈溢出，对于一个32位操作系统，最大管理4G内存，其中1G是给操作系统自己用，剩下的3G都是给用户程序的，一个用户程序理论上可以使用3G的内存空间
*/
```

![1569371890939](E:\git-workspace\note\images\c_languge\1569371890939.png)



```c
int c = 0;//静态区


void test(int a, int b)
{
    //打印a,b的地址
    printf("%d, %d\n", &a, &b);
}

int main()
{
    int a = 0;//栈区
    auto int b = 0;//所有的自动变量都在栈区
   
    printf("%d,%d\n", &a, &b);//分别打印变量a,b的地址
    //他们的地址相差四个字节，说明他们的地址是紧挨着的
    
    printf("%d,%d,%d\n", &a, &b, &c);//打印c的地址
    
    printf("%d,%d,%d,%d\n", &a, &b, &c, main);//打印main函数的地址
    //main函数是在代码区
    
    static int d = 0;//静态区，和上面的静态变量c是挨着的
    printf("%d,%d,%d,%d,%d\n", &a, &b, &c, &d, main);
    
    //打印函数形参的地址
    test(a, b);
}
```



## 静态区

![1569372173439](E:\git-workspace\note\images\c_languge\1569372173439.png)

![1569372483250](E:\git-workspace\note\images\c_languge\1569372483250.png)

## 代码区

![1569372338875](E:\git-workspace\note\images\c_languge\1569372338875.png)

## 栈区

栈区地址比较

![1569372058776](E:\git-workspace\note\images\c_languge\1569372058776.png)

栈区：函数形参

![1569372987490](E:\git-workspace\note\images\c_languge\1569372987490.png)
栈结构说明

![1569373595226](E:\git-workspace\note\images\c_languge\1569373595226.png)


操作栈地址，无效

```c
int * geta()
{
    int a = 100;
    return &a;//不能将一个栈变量的地址通过一个函数的返回值返回，因为在函数返回的时候，栈变量就会释放，这个地址是一个无效的地址
}

int main()
{
    int *p = geta();//这里返回的是一个栈的变量的地址，这个地址在函数返回的时候，会释放，所以这个地址是无效的
    *p = 1000;//对无效地址进行操作
    printf("%d\n", *p);
}
```

栈溢出

```c
int main()
{
    //分配了一个100M空间,会产生栈溢出
    char array[1024*1024*100] = {0};//定义一个超大的数组，一定会栈溢出
    array[0] = 'a';
	
    return 0;
}
```

## 堆的分配和释放

```c
//malloc
void * malloc(size_t _Size);
//malloc函数在堆中分配参数_Size指定大小的内存，单位：字节，函数返回void*指针

#include <stdlib.h>
int main(void)
{
    //在堆中申请了10个int大小的空间,返回分配内存的首地址
    int *p = (int *)malloc(sizeof(int)*10);//在堆中间申请内存，堆的内存在32位系统中接近3G
    //在堆中申请了10char这么大的空间
    char *p1 = (char *)malloc(sizeof(char)*10);
    
    
    //malloc和free一定要成对使用：即有分配就有释放，不然会有内存泄漏的问题
    //释放空间
    free(p);//释放通过malloc分配的堆内存
    //free(p);//释放两次，error,一块内存不能free两次
    free(p1);//释放通过malloc分配的堆内存
    
}
```

使用分配的堆内存

```c
#include <stdlib.h>
int main(void)
{
    //栈数组
    int array[10] = {0};
    //堆数组
    int *p = (int *)malloc(sizeof(int)*10);
    
    //p = array;//指针指向了栈空间的地址
    
    //首先清空这块堆内存
    memset(p, 0, sizeof(int)*10);
    //赋值
    int i;
    for(i=0; i<10; i++)
    {
        p[i] = i;
    }
    
    //释放空间
    free(p);//释放通过malloc分配的堆内存
    //如果p指向的是栈空间的地址，那么此时不需要free，栈空间程序会自动释放
}
```

函数中返回堆地址

```c
int * geta1()//可以通过函数的返回值返回一个堆地址，但是记得一定要free
{
    int *p = (int *)malloc(sizeof(int));//申请了堆空间
    return p;
}

int *geta2()//合法的，
{
    static int a = 0;
    return &a;//返回静态区的地址
}

int main(void)
{
    int * p = geta1();
    *p = 100;
    free(p);
    
    int * p2 = geta2();//ok
    *p2 = 100;//ok
    //free(p);//error，静态区的内存不能free
    
    return 0;
}
```

指针值传递问题

```c
void getheap(int *P)//这是两个不同的变量
{
    printf("p=%p\n", &p);
    //分配空间
    p = malloc(sizeof(int)*100);  
    //整个函数执行完之后，p这个栈变量就不存在了，导致他指向的具体堆空间的没有释放，那么就会有内存泄漏问题
}

int main(void)
{
    int *p = NULL;
    printf("address p=%p\n", &p);
    getheap(p);//error，此时p还是指向的是NULL
    printf("%d\n", p);
    p[0] = 1;//p没有指向任何内存，不能进行这样的操作
    p[1] = 2;

    free(p);
    
    return 0;
}
```

![1569460233385](E:\git-workspace\note\images\c_languge\1569460233385.png)

36：00