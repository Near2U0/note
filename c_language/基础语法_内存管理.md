[TOC]

# 作用域

代码块作用域

```c
int main(void)
{
  int a = 10;
  a = 1;
  {
    int a = 100;
  }
  
  printf("%d\n", a);//1
}
```

全局作用域

```c
int a = 200;//全局变量
int main(void)
{
  int a = 10;
  a = 1;
  {
    int a = 100;
  }
  
  printf("%d\n", a);//1
}
```

文件中定义变量

```c
//vi a.c
int a = 10;

//vi main.c
extern int a;//有一个int类型的变量，名字为age，已经在其他文件中定义了，这里可以直接使用
void set_age(int n)
{
  age = n;
}
void get_age()
{
  printf("%d\n", age);
}
int main(void)
{
  set_age(10);
  get_age();
}
```

auto自动变量

```c
auto int a = 0;//
int a = 0;//不写auto，C语言默认变量都是auto，signed
//自动变量，不需要关心变量在内存中什么时候创建和释放，由编译器解决
```

register寄存器变量

```c
/**
通常变量在内存当中，如果能把变量放到CPU的寄存器中，代码的执行效率会更高
*/
register int i = 0;//建议：如果有寄存器空闲，那么这个变量将放入寄存器中
//int *p = &i;//error，因为指针中存放的是内存地址，但是寄存器是没有内存地址的，所以对于一个寄存器变量是不能取地址的
```

静态局部变量

```c
void mystatic()
{
  static int i = 0;//这句话只会执行一次，不管函数调用多少次
  printf("%d", i);//静态变量，只初始化一次，并且程序运行期间，静态变量一直存在
  i++;
}
int main(void)
{
  int i = 0;
  for(;i<10;i++)
  {
    mystatic();
  }
}
```

![image-20190924231249189](/Users/chenyansong/Documents/note/images/c_languge/image-20190924231249189.png)

静态全局变量

```c
static int a = 20;//静态全局变量


```

静态函数

```c
//此函数只能在该文件中使用
static void test()
{
    int a = 2;
}

//默认情况下，此函数是全局的
void test()
{
    int a = 2;
}
```

调用其他文件的函数

```c
//vim a.c
void test2()
{
    int a = 2;
}

//============================
//vim main.c
void test2();//声明
//extern void test2();//等价声明

/*
extern int age;//1个含义，声明一个变量，此时变量一定已经定义了
int age;//2个含义：1.声明一个变量（如果已经定义了一个变量）；2.定义一个变量
*/
int main()
{
    test2();//调用
    
    return 0;
}
```

# 内存四区

```c
/**
代码区：程序被操作系统加载到内存的时候，所有的可执行代码都被加载到代码区，也叫代码段，这块内存是不可以在运行期间修改的
静态区：静态变量和全局变量
堆区：
栈区：stack是一种先进后出的内存结构，所有的自动变量，函数的形参都是由编译器自动放出栈中，当一个自动变量超出其作用域时，自动从栈中弹出
//对于自动变量，什么时候入栈，什么时候出栈，是不需要程序控制的，由C语言编译器实现
*/
```

![1569371890939](E:\git-workspace\note\images\c_languge\1569371890939.png)



```c
int c = 0;//静态区


void test(int a, int b)
{
    //打印a,b的地址
    printf("%d, %d\n", &a, &b);
}

int main()
{
    int a = 0;//栈区
    auto int b = 0;//所有的自动变量都在栈区
   
    printf("%d,%d\n", &a, &b);//分别打印变量a,b的地址
    //他们的地址相差四个字节，说明他们的地址是紧挨着的
    
    printf("%d,%d,%d\n", &a, &b, &c);//打印c的地址
    
    printf("%d,%d,%d,%d\n", &a, &b, &c, main);//打印main函数的地址
    //main函数是在代码区
    
    static int d = 0;//静态区，和上面的静态变量c是挨着的
    printf("%d,%d,%d,%d,%d\n", &a, &b, &c, &d, main);
    
    //打印函数形参的地址
    test(a, b);
}
```

栈区地址比较

![1569372058776](E:\git-workspace\note\images\c_languge\1569372058776.png)

栈区：函数形参

![1569372987490](E:\git-workspace\note\images\c_languge\1569372987490.png)

静态区

![1569372173439](E:\git-workspace\note\images\c_languge\1569372173439.png)

![1569372483250](E:\git-workspace\note\images\c_languge\1569372483250.png)

代码区

![1569372338875](E:\git-workspace\note\images\c_languge\1569372338875.png)

栈结构说明

![1569373595226](E:\git-workspace\note\images\c_languge\1569373595226.png)

操作栈地址，无效

```c
int * geta()
{
    int a = 100;
    return &a;
}

int main()
{
    int *p = geta();//这里返回的是一个栈的变量的地址，这个地址在函数返回的时候，会释放，所以这个地址是无效的
    *p = 1000;//对无效地址进行操作
    printf("%d\n", *p);
}
```







