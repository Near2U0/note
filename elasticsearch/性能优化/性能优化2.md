[TOC]

# Elasticsearch的索引思路

将磁盘里的东西尽量搬进内存，减少磁盘随机读取次数(同时也利用磁盘顺序读特性)，结合各种高级的压缩算法，用及其苛刻的态度使用内存。
所以，对于使用Elasticsearch进行索引时需要注意:

* 不需要索引的字段，一定要明确定义出来，因为默认是自动建索引的
* 同样的道理，对于String类型的字段，不需要analysis的也需要明确定义出来，因为默认也是会analysis的
* 选择有规律的ID很重要，随机性太大的ID(比如java的UUID)不利于查询

关于最后一点，个人认为有多个因素:
其中一个(也许不是最重要的)因素: 上面看到的压缩算法，都是对Posting list里的大量ID进行压缩的，那如果ID是顺序的，或者是有公共前缀等具有一定规律性的ID，压缩比会比较高；
另外一个因素: 可能是最影响查询性能的，应该是最后通过Posting list里的ID到磁盘中查找Document信息的那步，因为Elasticsearch是分Segment存储的，根据ID这个大范围的Term定位到Segment的效率直接影响了最后查询的性能，如果ID是有规律的，可以快速跳过不包含该ID的Segment，从而减少不必要的磁盘读次数

ES报 “打开的文件过多” 问题

“非查询字段”不建索引 index store

https://blog.csdn.net/zhanlanmg/article/details/50847732




图解Elasticsearch中的_source、_all、store和index属性

https://blog.csdn.net/napoay/article/details/62233031



_all字段的作用

https://blog.csdn.net/jiao_fuyou/article/details/49800969

```c
Disabling _all字段
_all 字段可以被完全的disabled:

PUT my_index
{
  "mappings": {
    "type_1": { 
      "properties": {...}
    },
    "type_2": { 
      "_all": {
        "enabled": false
      },
      "properties": {...}
    }
  }
}

```



优化的方式

```shell
#1.include_in_all


#2.index 
	no #不让查询的字段
	not_analyzed  #原字段，原封不动的添加到索引中
	
#3.store
	只是存储有用的字段
#4.默认映射中取消_all
{
	"mappings":{
		"_default":{
			"_all":{"enabled": false}
		},
		"user":{
			//.....
		}
	}
}
```











