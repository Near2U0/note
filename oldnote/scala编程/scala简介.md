---
title: 第一章 scala简介
categories: scala   
tags: [scala,scala编程]
---

本书的所有例子能在scala 版本的2.7.2下面编译通过

# 1.函数式编程
&emsp;Eric Raymond 把大教堂和集市作为软件开发的两个隐喻,大教堂是几乎近于完美的建筑物,要花很长的时间建设,而一旦建成了就长时间保持不变,相对来说,集市则天天在被工作在其中的人调整和扩展
Raymond 的文章中,集市是对于开源软件开发的隐喻, Scala更像是一个集市而不是大教堂,因为他被设计为可以让使用它的人扩展和修改,Scala并没有提供那种"完美齐全"语言中可能需要的所有的东西,而是把制作这些东西的工具放在了你的手中

&emsp;Scala是纯粹的面向对象语言,每个值都是对象,每个操作都是方法,例如:如果使用Scala描述:1+2 ,实际上等于条用定义在Int类里的+方法,方法名可以用像操作符一样的名字定义,以便于API的使用者像使用操作符那样使用方法

&emsp;Scala还是一种成熟的函数式语言,函数式编程有两种指导理念,第一种理念是函数是头等值,在函数式语言中,函数也是值,与整数或字符串处于同一个地位,函数可以被当做参数传递给其他函数,可以当做结果从函数中返回或保存在变量里,可以在函数里定义其他函数,就好像在函数里定义整数一样,还可以定义匿名函数,并随意的插入到代码的任何地方,就好像使用43这样的整数字面量一样
函数式编程的第二种理念是程序的操作应该把输入值映射为输出值而不是就地修改数据,在Java和scala里,字符串是一种数学意义上的额字符序列,使用s.replace(':', '.') 这样的表达式替换字符串里的字符会产生一个新的,不同于原字符串s的对象,换句话说就是Java里字符串是不可变的而在一些其他的语言中是可变的,因此单就字符串来说,Java是函数式的语言,不可变数据结构是函数式语言的一块基石,Scala库在Java API之上定义了更多的不可变数据类型,例如:Scala有不可变的列表 , 元组, 映射表, 和集

&emsp;函数式编程第二种理念的另一种解释是,方法不应该有任何的副作用,方法与其所在的环境交流的唯一方式应该是获得参数和返回结果,比如Java里String类的replace方法就是符合这种说法,他的参数包含一个字符串和两个字符串,返回的是一个新的字符串,其中的指定字符串都替换成了另一个,调用replace不会有其他的结果,类似于replace这样的方法被称为  指称透明 , 就是说对于任何输入来讲,都可以用方法的结果替代对他的调用,而不影响程序的语义


# 2.Why Scala?

1. Scala是兼容的
&emsp;scala不需要你脱离Java平台重新学习开发,他可以让你保全现存的代码并添加新东西因为他被设计成可以与Java实施无缝的互操作,Scala程序会被编译成JVM的字节码,其运行时的性能通常与Java程序不分上下,scala代码可以调用Java方法,访问Java字段,继承Java类和实现Java接口,这些都不需要特别的语法,外部接口描述或胶水代码,实际上,程序员们根本都没有意识到,几乎所有Scala代码都大量使用了Java库代码与Java的全交互操作性的另一个方面是Scala大量重用了Java类型,Scala的Int类型代表了Java的原始整数类型Int,Float代表了float等等,Scala不仅重用了Java的类型,而且还把他们打扮得更好看,如Scala的字符串类似于toInt 和toFloat的方法,可以把字符串转换成整数或浮点数,因此可以用str.toInt 代替 Integer.parseInt(str) 方法,不过他在不打破互操作性的基础上是怎么做到这点的呢?Java的String类可没有toInt方法,实际上,Scala有一个通用方案可以解决这种高级库设计和互操作性相对立的问题,Scala允许定义类型失配或者选用不存在的方法时使用隐式转换,在上面的例子里,当在字符串中寻找toInt方法时,Scala编译器会发现String类里没有这种方法,但他会发现Java的String对象转换为Scala的RichString 类实例的隐式转换,而RichString类中定义了这么个方法,于是在执行toInt操作之前,转换被隐式应用了

2. Scala是简洁的
有一种极端的例子是,Scala的代码可以减少到Java的1/10,较为保守的估计大概标准的Scala程序代码行在Java里写的同样程序的一般左右,更少的行数不仅意味着打更少的字,同样意味着更少的对程序的阅读和理解,以及更少出错的机会,如:Java和scala的构造函数的对比就可以看出来了


3. scala是高级的

```
#java 写法
boolean nameHasUpperCase = false;
for (int i=0; i<name.length(); i++){
    if(Character.isUpperCase(name.charAt(i))){
        nameHasUpperCase = true;
        break;
    }
}



#scala写法
val nameHasUpperCase = name.exists(_.isUpperCase)

```
4. scala是静态类型的
&emsp;scala是以Java的内嵌类型系统为基础,允许使用泛型参数化类型,用交集组合类型及抽象类型影藏类型细节,这都为自建类型打下了坚实的基础,从而能够设计出既安全又灵活使用的接口,静态类型检查可以提供一些基础的编码上的检查,从而避免在程序运行时出错而重新排错的可能

