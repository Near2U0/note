# 1.sparkContext 的初始化的过程

* taskScheduler的创建(注册application，调度池问题)
* backend
* spark UI
* dagScheduler 

driver 的由来

1. 在sparkcontext创建的时候，会创建一个

```
val (sched, ts) = SparkContext.createTaskScheduler(this, master, deployMode)
// 这个方法会返回一个schedulerBackend，和TaskSchedulerImpl

schedulerBackend 有具体的 实现类， 。。。。 ，他负责向Master注册，接收Executor的反注册，将task发送到Executor等操作


SparkContext.createTaskScheduler在方法内部生成了TaskSchedulerImpl，然后会调用TaskSchedulerImpl的initialize,这里会创建一个调度池，（两种不同类型的调度池：FIFO,FAIR），


接着sparkcontext向下走

_taskScheduler.start()


    _taskScheduler.start() // _taskScheduler 里面有一个backend，这个backend启动会去启动 driver，并让driver向Master注册
这里会涉及到：Driver向Master注册

```


2. sparkContext在创建的时候，同时会创建 dagScheduler，其底层的是依赖DAGSchedulerEventProcessLoop进行通信（核心）

3. spark UI 在此时创建，默认访问404端口


# 2.Master的主备切换

spark内核源码二之Master原理解析


# 3.Master的注册机制

1.worker的注册
2.driver的注册

Master.receiveAndReply() 方法中有对应的方法


3.application的注册

这个是backend内部的APPClient向Master发送RegisterApplication

Master.receive() 方法中

waitingApps中存放的是等待的application，在schedule()方法调用的时候，会从waitingApps中取出一个一个的application，然后为这些application去启动Executor



![](/Users/chenyansong/Documents/note/img/bigdata/spark从入门到精通_笔记/master的注册机制.png)


# 4.Master状态改变处理机制原理剖析与源码分析

1.DriverStateChanged

```
# 如果driver的状态是下面中的几种，那么会将driver移除
case DriverState.ERROR | DriverState.FINISHED | DriverState.KILLED |    DriverState.FAILED =>
          removeDriver(driverId, state, exception)
```

2.ExecutorStateChanged


# 5.mater中的schedule方法的调用

