---
title: zookeeper运维日常
categories: hadoop   
tags: [zookeeper]
---


# 性能优化

* Zk本身是基于java实现的，因此,调大JVM内存是优化点之一,具体数额需要根据业务情况来定,涉及到的JVM参数为-Xmx-Xms-Xmn
* IO优化:把事务日志与快照存储分磁盘存储,提高IOPS,最好事务日志单独磁盘挂载
* 加大linux系统的文件句柄数和用户线程数,通过linux的命令ulimit可以查看当前的配置
* 业务并发高时,可以创建多于1个的客户端会话,可以不同的业务模块采用不同的客户端实例
* 利用zk进行业务开发时,尽量通过良好的设计减少资源消耗,比如watcher的数量
* 节点数量,在写少,读多应用场景,采用多一点的节点会提升整体的读并发性能
* 节点数据最好比默认的10M还小
* 带宽尽量高,可以通过网络监控查看带宽是否已经是瓶颈



# 扩容

* 停机
增加相应的节点即可,比较简单


* 不停机
	* 增加新的节点,id一定要比原来集群的要大
	* 新节点启动后会加入集群,并且同步数据
	* 当用mntr命令查看新的节点数据已经同步成功后做下面的操作
	* 按照之前的id顺序依次再去关闭zk实例,然后修改配置,启动实例


# 容灾

* 单机房的容灾靠zk本身的集群机制就能很好的支撑
* 多机房的容灾
由于多半投票机制,zk不支持双机房的容灾,比如5节点,分为2和3,当3这个机房出现故障	,2不能选举成功
因此,多机房容灾主要是考虑三机房的情况
跨机房的网络延时较大,做这个容灾要避免大量写应用场景

为了避免服务器的地址变化影响客户端,客户端尽量采用域名的方式


# 重点监控指标
* 连接数
* 注册的watchers数
* zk事件通知的延时是否过大
* zookeeper事务日志
	* 磁盘IO
	* 可以开启事务日志自动清理
		* autopurge.snapRetainCount
		* autopurge.purgeInterval=24








