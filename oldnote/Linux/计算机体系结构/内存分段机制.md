[toc]

# 程序和数据在内存中的位置

因为处理器只知道取指令，执行指令，但是处理器并不能区别取到的二进制是指令还是数据，所以我们将指令（程序）和数据分开来存放在内存中的不同位置，并且我们逻辑上的给他们分成**代码段和数据段**





# 为什么程序需要重定位

因为程序被加载到内存是随机存放在内存的某个地址开始（**物理地址**）的地方，而这个物理地址，我们是没法知道的，所以就需要我们在程序中使用相对地址或者叫逻辑地址，**当程序加载时，这些相对地址还要根据程序实际被加载的位置重新计算**，这就是**程序的重定位**



# 内存分段机制

8086处理器解决上述问题的方式是：即使用**分段机制**，解决写死物理地址的问题

* 段地址：程序被加载到内存的起始物理地址（通常可以存放在CS，DS中）
* 偏移地址：相对于起始地址（段地址）的偏移量

使用分段策略之后，一个内存单元的物理地址可以用“段地址:偏移地址”来表示，这就是常说的逻辑地址

![image-20191221114737354](/Users/chenyansong/Documents/note/images/linux/tixijiegou/image-20191221114737354.png)



* CS (code segment): 对CS内容的改变将导致处理器从新的代码段开始执行
* DS(data segment): 对DS内容的改变将导致从新的数据段开始取数据

> 指令中指定的内存不再是内存的物理地址，而是段内偏移地址，这样一旦遇到一条访问内存的指令，他将把DS中的数据起始地址和指令中提供的段内偏移地址相加，来得到内存所需要的物理地址

当执行指令A1 02 00 时，处理器将DS中的内容和指令中指定的偏移地址0002H相加得到1002H，这是一个物理地址，处理器用它来访问内存，可以得到内存中的数据为00A0H

![image-20191221114250579](/Users/chenyansong/Documents/note/images/linux/tixijiegou/image-20191221114250579.png)



# 8086的内存分段机制

* 段寄存器：CS(代码段)，DS(数据段)，ES(附加段，当需要访问两个数据段的时候可以使用)，SS(栈段)
* 取指令的过程：CS+IP
* 访问数据的过程：DS+指令中的偏移地址；ES+指令中的偏移地址
* 8086的20根地址线：8086寄存器是16位的，16位的段地址+16位的偏移地址，只能形成16位的物理地址，所以$10^{16}=64KB$，但是为了访问1M的内存空间，将段地址左移4位，满足20位地址的空间，然后再加上16位的段偏移，得到的就是20位的物理地址，例如：逻辑地址F000H:052DH，将段地址F000H左移4位，变成F0000H，再加上052DH，就形成了20位的物理地址F052DH

> 因为段地址左移4位作为基址，所以段地址+段偏移地址（从0开始） 一定是按照16位对齐

