[TOC]

中断：打断处理器当前的执行流程，去执行另外一些和当前程序不相干的工作

# 外部硬件中断

从处理器外面来的中断信号

* 外部设备发生错误
* 有数据要传送（从网络中收到一个针对当前主机的数据包）
* 处理器交给外部设备的事情处理完了（比如打印）



外部中断是通过两根信号线引入处理器内部的，这两根线的名字叫：NMI和INTR

![image-20191226193055308](https://github.com/chenyansong1/note/blob/master/images/linux/x86/image-20191226193055308.png?raw=true)

## 非屏蔽中断

像读内存数据错误，或者是IO错误，处理器再工作下去是没有意义的，所以这些中断是要处理器必须立即处理，称之为非屏蔽中断(Non Maskable Interrupt, NMI)，这类中断有一个统一的中断号2

NMI高电平有效，从0跳变到1后，至少需要维持4个以上的时钟周期才算有效，才能被识别



## 可屏蔽中断

在可屏蔽中断前，会有一个代理，用来接收中断，并进行中断仲裁，以决定中断中的哪一个优先向处理器提出服务请求

中断代理，8259芯片（中断控制器），提供15个中断，但是中断号并不固定，该中断控制器芯片有自己的端口号，所以可以通过in和out指令来改变他的状态，所以这个芯片又叫可编程中断控制器（Programmable Interrupt Controller, PIC）

![image-20191226194124911](https://github.com/chenyansong1/note/blob/master/images/linux/x86/image-20191226194124911.png?raw=true)

* 中断屏蔽寄存器（Interrupt Mask Register，IMR），8位寄存器，对应着该芯片的8个中断输入引脚，0表示允许，1表示阻断，没有被阻断的引脚可以送信号到处理器

* 8259芯片的端口号

  * 主片：0x20, 0x21
  * 从片：0xa0, 0xa1

  可以通过这些端口访问8259，设置他的工作方式，包括IMR的内容

* 中断是否被允许，还要看处理器内部的一个中断标志位IF(IF=1,处理器可以接受和响应中断)，可以通过cli（Clear Interrupt flag=0）和sti(SeT Interrupt flag=1)来设置IF的值

* 中断优先级：和引脚相关，主片的IR0引脚优先级最高，IR7优先级最低，从片也是如此



## 实模式下的中断向量表

所谓中断处理，是处理器要执行一段与该中断相关的程序（指令）

## 中断向量表(Interrupt Vector Table, IVT)

* 中断的初始化：是由BIOS在启动时完成的，BIOS为每个中断号填写入口地址，因为他还不知道中断处理程序的位置（此时操作系统和应用程序还没有被加载到内存），所以一律将他们只向一个相同的入口地址，在那里只有一条指令：iret,当操作系统和用户程序需要，再来修改某些中断的入口，使他们只向自定义的中断程序

* 位置：0x0000-0x003ff
* 大小：每个中断向量表占2个字
* 8259芯片中每个引脚都赋予了一个信号（需要以芯片为单位来进行设置），可以指定主片的中断信号从0x08开始，那么每个引脚IR0-IR7所对应的终端信号分别是0x08-0x0f
* 中断时，处理器所做的事情
  * 保护断点现场：FLAGS压栈，清除IF，TF位，CS，IP压栈
  * 执行中断程序，将中断号*4得到中断项，从其中得到中断程序的段地址和偏移地址

![image-20191226201120783](https://github.com/chenyansong1/note/blob/master/images/linux/x86/image-20191226201120783.png?raw=true)



* 中断返回：中断程序的最后一条指令必须是iret,这将导致处理器从栈中弹出IP，CS，FLAGS，接着控制权交给主程序



## 实时时钟, CMOS RAM, BCD编码

外围设备控制芯片ICH内部，集成了实时时钟电路（Real Time Clock, RTC)和静态存储器（CMOS RAM），实时时钟电路负责向CMOS RAM中写入日期和时间数据

* RTC芯片的功能

  * 保存日期和时间
  * 提供闹钟
  * 周期性的终端功能
  * 通常128字节
    * 日期和时间
    * 各种硬件类型和工作参数
    * 开机密码
    * 辅助存储设备的启动顺序
    * 这些通常在BIOS SETUP开机程序中设定

* CMOS RAM中的时间信息

  ![image-20191226204732112](https://github.com/chenyansong1/note/blob/master/images/linux/x86/image-20191226204732112.png?raw=true)
  
* 访问端口

  索引端口：0x70和0x74，用来指定CMOS RAM内的单元

  数据端口：0x71和0x75，用来读写相应单元(上面选择的端口)里的内容

  ```assembly
  mov al, 0x06; 告诉芯片，我需要索引“星期”数据
  out 0x70, al
  in al, 0x71; 读出该数据
  ```

  > 端口0x70的最高位(bit 7)是控制NMI中断的开关，当他为0时，允许NMI终端到达处理器；为1时，则阻断所有的NMI信号；其他7个比特即0-6位，则实际上用于指定CMOS RAM单元的索引号

  ![1577418042958](https://github.com/chenyansong1/note/blob/master/images/linux/x86/1577418042958.png?raw=true)

  0x70端口能够写入是不够的，还要能够读出，因为将里面的内容用于随后的写索引操作中

* BCD编码

  二进制编码的十进制（Binary Coded Decimal， BCD）

  ```shell
  0001 1001 #十进制25
  0010 0101 #BCD：一个字节的高4位和低4位分别表示一个0到9之间的数字
  ```

## 时钟中断

1. 设置RTC寄存器B，设置阻断NMI
2. 设置RTC寄存器B，设置中断为 开放更新结束后中断
3. 读RTC寄存器C，复位未决的中断状态
4. 设置8259从片的IMR寄存器，R0设置为0，表示打开中断
5. sti重新开启中断标志位

```assembly
mov al,0x0b                        ;RTC寄存器B
or al,0x80                         ;阻断NMI 
out 0x70,al
mov al,0x12                        ;设置寄存器B，禁止周期性中断，开放更 
out 0x71,al                        ;新结束后中断，BCD码，24小时制 

mov al,0x0c
out 0x70,al
in al,0x71                         ;读RTC寄存器C，复位未决的中断状态

in al,0xa1                         ;读8259从片的IMR寄存器 
and al,0xfe                        ;清除bit 0(此位连接RTC)
out 0xa1,al                        ;写回此寄存器 

sti                                ;重新开放中断 
```

# 内部中断

和硬件中断不同，内部中断发生在处理器内部，是由执行的指令引起的，比如除0操作，再比如处理器遇到非法指令时，将产生中断6

# 软中断

软中断是由int指令引起的中断处理，这类中断不需要中断识别总线周期，中断号在指令中给出

```assembly
int3   ;断点中断，嵌入程序中方便调试；和int 3不同，这个是3号中断
int imm8
into ;溢出中断指令，当处理器执行这条指令时，如果标志寄存器OF位为1，那么将产生4号中断，否者这条指令什么也不做
```

## BIOS中断

1. 操作系统会以中断处理程序的形式提供一些例程给应用程序调用，比如硬盘读写操作，

2. 操作系统会将这些例程的地址填写到中断向量表中
3. 应用程序只需要发出一个软中断即可调用操作系统的例程



* BIOS中断，又称之为BIOS功能调用

  1. 这些中断是在计算机加电之后，BIOS程序执行期间建立起来的（也就是说这些中断功能在加载和执行主引导扇区之前，就已经可以使用了）

  2. 主要是为了方便使用最基本的硬件访问功能，不同的硬件使用不同的中断号，比如键盘服务，中断号0x16

     ```assembly
     int 0x16
     ```

  3. 为了区分对同一硬件的不同功能，使用寄存器AH来指定具体的功能编号，如下指令从键盘读取一个按键

     ```assembly
     mov ah, 0x00 	;从键盘读字符
     int 0x16  		;键盘服务，返回时，字符ASCII在寄存器AL中
     ```

  4. 屏幕显示字符

     ```assembly
   ;中断0x10的0x0e号功能；该功能用于在屏幕上的光标位置处写一个字符，并推进光标位置
     mov ah,0x0e
   mov al,[bx] ;需要显示的字符
     int 0x10
     ```
  
  5. 接收键盘输入并屏幕显示
  
     ```assembly
     ;0x16的0x00功能表示从键盘读字符
     ;AL中为字符的ASCII码
     
     ;从键盘读
     mov ah,0x00
     int 0x16
     ;显示到屏幕
     mov ah,0x0e
     mov bl,0x07
     int 0x10
     ```
  
  6. BIOS可能会为一些简单的外围设备提供初始化和功能调用的代码，并填写中断向量表，单也有一些BIOS中断是由外部设备接口自己建立的
  
  7. 外部设备有自己的ROM，这些ROM中提供了设备自己的功能调用例程，以及本设备的初始化代码，按照规范，格式如下：
  
     ![1577434705929](https://github.com/chenyansong1/note/blob/master/images/linux/x86/1577434705929.png?raw=true)
  
  8. 在计算机启动期间，BIOS程序会以2KB为单位搜索内存地址C0000-E0000之间的区域，当他发现某个区域的头两个字节是0x55和0xAA时，那意味着该区域ROM代码存在，是有效的，接着对该区域做累加和检查，看结果是否和第三个单元相符，如果相符，就从第四个单元进入，最后填写相关的中断向量表，使他们指向自带的中断处理过程

## 常见的BIOS中断





### BIOS的中断向量表

中断向量表位置

中断向量表位于BIOS的 0x0000 - 0x03FF 地方，大小为 1k。

| 中断号 |                                                 | 说明: int 中断号 |
| ------ | ----------------------------------------------- | ---------------- |
| 0x00   | DIVIDE ERROR                                    |                  |
| 0x10   | **VIDEO**                                       | **显示**         |
| 0x11   | GET EQUIPMENT LIST                              | 设备列表         |
| 0x12   | GET MEMORY SIZE                                 | 内存大小         |
| 0x13   | **DISK**                                        | **磁盘**         |
| 0x14   | **SERIAL**                                      | **串行口服务**   |
| 0x15   | SYSTEM                                          | 系统             |
| 0x16   | **KEYBOARD**                                    | **键盘**         |
| 0x17   | PRINTER                                         | 打印机           |
| 0x18   | CASETTE BASIC                                   |                  |
| 0x19   | BOOTSTRAP LOADER                                | 时钟             |
| 0x1a   | TIME                                            | **时钟服务**     |



详细参见：https://blog.csdn.net/weixin_37656939/article/details/79684611

