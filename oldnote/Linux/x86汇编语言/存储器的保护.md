[TOC]

存储器的保护功能可以禁止程序的非法访问内存，比如向代码段写入数据，访问段界限之外的内存位置，当然利用这种功能，也可以实现一些有价值的功能，比如虚拟内存管理，当处理器访问一个实际上不存在的段时，会引发异常中断，操作系统利用这一点，通过接管异常处理过程，并用硬盘来进行段的换入和换出操作

# 段别名

```assembly
         ;创建0#描述符，它是空描述符，这是处理器的要求
         mov dword [ebx+0x00],0x00000000
         mov dword [ebx+0x04],0x00000000  

         ;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间
         mov dword [ebx+0x08],0x0000ffff    ;基地址为0，段界限为0xfffff
         mov dword [ebx+0x0c],0x00cf9200    ;粒度为4KB，存储器段描述符 

         ;创建保护模式下初始代码段描述符
         mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，512字节 
         mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符 

         ;创建以上代码段的别名描述符
         mov dword [ebx+0x18],0x7c0001ff    ;基地址为0x00007c00，512字节
         mov dword [ebx+0x1c],0x00409200    ;粒度为1个字节，数据段描述符

         mov dword [ebx+0x20],0x7c00fffe
         mov dword [ebx+0x24],0x00cf9600
         
;在保护模式下，代码段是不可写入的，即不能通过CS操作写入，但是很多时候，我们希望对代码段做一些修改，比如在程序调试的时候，需要加入断点指令int3
;所以如果需要访问代码段内的数据，只能重新为该段安装一个新的描述符，并将其定义为可读可写的数据段，然后修改代码段内的数据时，通过这个新的描述符来进行
```



通过type可以确定是数据段，代码段，栈段；

数据段（栈段）和代码段通过type中的是否可以执行来区分（代码段可以执行，其他不能执行）

数据段和栈段通过Type中的扩展方向来区分（栈向下扩展，数据段向上扩展）



![image-20191229120408624](https://github.com/chenyansong1/note/blob/master/images/linux/x86/image-20191229120408624.png?raw=true)





# 段界限

这里说的**界限就是偏移量**

* 数据段和代码段的界限

  ```shell
  #段的粒度是4KB
  (描述符中的段界限值+1) x 0x1 -1
  
  #段的粒度是1KB
  (描述符中的段界限值+1) x 0x1000 -1
  ```



* 栈段的界限

  ```shell
  #ESP > 段界限 x 粒度值
  #所以每次压栈或者入栈时，只要ESP的值能够大于最下的下限，那么操作就合法，但是这里存在一个问题：如果ESP指向的是0xFFFFFFFF，这个是4G内存的最大值，但是这个值也是小于下限的，所以也可以看成是合法的，所以这样定义的栈的访问是存在问题的
  ```


# 修改段寄存器时的保护

这里会有两个检查：

1. 指定的段寄存器的索引号是否在GDT或者LDT内（索引号*8+7 <= 边界）

   ![1577670282193](https://github.com/chenyansong1/note/blob/master/images/linux/x86/1577670282193.png?raw=true)

2. 取得描述符后，还要对描述符的类别进行确认

   1. 描述符的类别字段必须是有效的值

   2. 检查描述符的类别是否和段寄存器的用途匹配

      ![](https://github.com/chenyansong1/note/blob/master/images/linux/x86/1577671227844.png?raw=true)
      
   3. P为检查，如果P=0，从磁盘重新调入到内存

# 栈操作时的保护

## 保护模式下的栈

对于向上扩展的段，比如数据段，段内偏移量是从0开始递增的，偏移量的最大值是：**界限值和粒度的乘积**

对于向下扩展的段，比如栈段，段内偏移量的最小值是：**界限值和粒度的乘积加一**，即栈操作时必须符合以下条件：

```shell
ESP > 段界限 x 粒度值
```

> 所以每次压栈或者入栈时，只要ESP的值能够大于最下的下限，那么操作就合法，但是这里存在一个问题：**如果ESP指向的是0xFFFFFFFF，这个是4G内存的最大值，但是这个值也是小于下限的，所以也可以看成是合法的，所以这样定义的栈的访问是存在问题的**



# 数据访问时的保护

## 代码段执行时的保护

代码段寄存器CS，在赋值操作的时候，会使用相应的描述符初始其描述符高速缓存器，后面处理器取指执行时，不在访问描述符表，而是直接使用段寄存器的描述符高速缓存器，从中取得线性地址，通EIP相加得到32位的物理地址，这个就是下一条需要执行的指令

段界限

```cmd
#G=0
#实际使用的段界限就是描述符中记载的段界限

#G=1，实际使用的段界限为：
#描述符中的段界限值 * 0x1000 +0xFFF
```

因为代码段是向上扩展的，实际使用的段界限就是当前段内最后一个允许访问的偏移地址，所以EIP需要进行如下的判断

```shell
0<= (EIP+指令长度-1) <= 实际使用的段界限
```

代码段描述符中给出的边界值是0x001FF，粒度为字节，可以认为他就是段内最后一个允许访问的偏移地址

![](https://github.com/chenyansong1/note/blob/master/images/linux/x86/image-20191230194241052.png?raw=true)

## 栈操作时的保护

栈的增长方向：向低地址方向推进

```shell
#G=0
#实际使用的段界限就是描述符中记载的段界限

#G=1，实际使用的段界限为：
#描述符中的段界限值 * 0x1000 +0xFFF
```

因为栈是向下扩展的，所以每当往栈中压入数据时，ESP的内容要减去操作数的长度实际使用的段界限就是段内不允许访问的最低端偏移地址，**至于最高端的地址，则没有限制，最大可以是0xFFFFFFFF**，如下

```shell
# 实际使用的段界限 + 1 <= (ESP内容 - 操作数的长度) <=0xFFFFFFFF
```

栈段的线性基址为0x00007C00，栈的界限为0xFFFFE，粒度为4KB，，并设置栈指针寄存器ESP的初值为0

```shell
#因为段界限的粒度是4KB(G=1)，故实际使用的段界限为：
0xFFFFE * 0x1000 + 0xFFF = 0xFFFFEFFF
```

又因为ESP的最大值为0xFFFFFFFF，因此在操作栈时，处理器的检查规则是

```shell
0xFFFFEFFF+!=0xFFFFF000 <= (ESP-操作数的长度) <= 0xFFFFFFFF
```

以上仅仅是偏移地址，要得到实际的物理地址，需要加上SS(0x7C00)的内容

```shell
#低端有效地址
0x00007C00 + 0xFFFFF000 = 0x00006C00

#高端有效地址
0x00007C00 + 0xFFFFFFFF = 0x00007BFF
```

也就是说：当前程序所定义的栈空间介于地址0x00006C00 - 0x00007BFF 之间，大小是4KB



## 数据访问时的保护

数据访问的段界限也就是段内偏移

```shell
#G=0
#实际使用的段界限就是描述符中记载的段界限

#G=1，实际使用的段界限为：
#描述符中的段界限值 * 0x1000 +0xFFF
```

例如

```assembly
mov [0x2000], edx ;EA=0x2000

#0<= (EA+操作数大小-1) <=实际使用的段界限
```









