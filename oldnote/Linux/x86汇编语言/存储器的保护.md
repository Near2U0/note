[TOC]

存储器的保护功能可以禁止程序的非法访问内存，比如向代码段写入数据，访问段界限之外的内存位置，当然利用这种功能，也可以实现一些有价值的功能，比如虚拟内存管理，当处理器访问一个实际上不存在的段时，会引发异常中断，操作系统利用这一点，通过接管异常处理过程，并用硬盘来进行段的换入和换出操作

# 段别名

```assembly
         ;创建0#描述符，它是空描述符，这是处理器的要求
         mov dword [ebx+0x00],0x00000000
         mov dword [ebx+0x04],0x00000000  

         ;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间
         mov dword [ebx+0x08],0x0000ffff    ;基地址为0，段界限为0xfffff
         mov dword [ebx+0x0c],0x00cf9200    ;粒度为4KB，存储器段描述符 

         ;创建保护模式下初始代码段描述符
         mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，512字节 
         mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符 

         ;创建以上代码段的别名描述符
         mov dword [ebx+0x18],0x7c0001ff    ;基地址为0x00007c00，512字节
         mov dword [ebx+0x1c],0x00409200    ;粒度为1个字节，数据段描述符

         mov dword [ebx+0x20],0x7c00fffe
         mov dword [ebx+0x24],0x00cf9600
         
;在保护模式下，代码段是不可写入的，即不能通过CS操作写入，但是很多时候，我们希望对代码段做一些修改，比如在程序调试的时候，需要加入断点指令int3
;所以如果需要访问代码段内的数据，只能重新为该段安装一个新的描述符，并将其定义为可读可写的数据段，然后修改代码段内的数据时，通过这个新的描述符来进行
```



通过type可以确定是数据段，代码段，栈段；

数据段（栈段）和代码段通过type中的是否可以执行来区分（代码段可以执行，其他不能执行）

数据段和栈段通过Type中的扩展方向来区分（栈向下扩展，数据段向上扩展）



![image-20191229120408624](https://github.com/chenyansong1/note/blob/master/images/linux/x86/image-20191229120408624.png?raw=true)





# 段界限

这里说的**界限就是偏移量**

* 数据段和代码段的界限

  ```shell
  #段的粒度是4KB
  (描述符中的段界限值+1) x 0x1 -1
  
  #段的粒度是1KB
  (描述符中的段界限值+1) x 0x1000 -1
  ```



* 栈段的界限

  ```shell
  #ESP > 段界限 x 粒度值
  #所以每次压栈或者入栈时，只要ESP的值能够大于最下的下限，那么操作就合法，但是这里存在一个问题：如果ESP指向的是0xFFFFFFFF，这个是4G内存的最大值，但是这个值也是小于下限的，所以也可以看成是合法的，所以这样定义的栈的访问是存在问题的
  ```


# 修改段寄存器时的保护

这里会有两个检查：

1. 指定的段寄存器的索引号是否在GDT或者LDT内（索引号*8+7 <= 边界）

   ![1577670282193](E:\git-workspace\note\images\linux\x86\1577670282193.png)

2. 取得描述符后，还要对描述符的类别进行确认

   1. 描述符的类别字段必须是有效的值

   2. 检查描述符的类别是否和段寄存器的用途匹配

      ![](E:\git-workspace\note\images\linux\x86\1577671227844.png)
      
   3. P为检查，如果P=0，从磁盘重新调入到内存

# 栈操作时的保护

## 保护模式下的栈

对于向上扩展的段，比如数据段，段内偏移量是从0开始递增的，偏移量的最大值是：**界限值和粒度的乘积**

对于向下扩展的段，比如栈段，段内偏移量的最小值是：**界限值和粒度的乘积加一**，即栈操作时必须符合以下条件：

```shell
ESP > 段界限 x 粒度值
```

> 所以每次压栈或者入栈时，只要ESP的值能够大于最下的下限，那么操作就合法，但是这里存在一个问题：**如果ESP指向的是0xFFFFFFFF，这个是4G内存的最大值，但是这个值也是小于下限的，所以也可以看成是合法的，所以这样定义的栈的访问是存在问题的**



























# 数据访问时的保护




```

```