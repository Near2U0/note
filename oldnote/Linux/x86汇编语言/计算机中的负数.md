[TOC]

# 负数是怎么得到的



计算机中的负数：

负数是怎么得到的

```shell
# -1的表示方式就是：0-1 ,如果是8位存储那么，将如下
  0000 0000	#向最高位借1
- 0000 0001
-------------
  1111 1110  # 0xFF
  
#同理下面也是成立的：
data0 db -1   # 初始化为0xFF
data1 db -2   # 初始化为0xFE
data2 dw -1   # 初始化为0xFFFF
data3 dw -2   # 初始化为0xFFFE


```



得到一个负数的形式就是0-Number 得到这个Number的负数形式

```shell
#AL=0000 1000          8
neg al	#AL=1111 1000 -8


```

> neg: 用0减去指令中指定的操作数

# 符号位扩展

符号位扩展，cbw , cwd 是没有操作数的

* cbw ： 8位扩展到16位，将寄存器AL中的符号位扩展到整个AX

  ```shell
  AL=0100 1111
  cbw  # AL=0000 0000 0100 1111
  
  AL=1100 1111
  cbw  # AL=1111 1111 1100 1111
  ```

  

* cwd ： 16位扩展到32位，将寄存器AX中的有符号数扩展到DX：AX

  ```shell
  #AX=0100 1111 0111 1001
  cwd # AX内容不变； DX=0000 0000 0000 0000
  
  #AX=1100 1111 0111 1001
  cwd # AX内容不变； DX=1111 1111 1111 1111
  ```

  > 同一个数，比如 -3 ，如果使用8位存储表现形式为0xFD，但是如果是16位存储，那么表现形式为0xFFFD，所以如果是一个8位的有符号数，想要用16位的形式来表示，是需要扩展最高位的



# 处理器视角看数据类型

对于一个数，处理器是将它看做有符号数，还是无符号数，这个取决于程序怎么看，对于处理器的多数指令来说，执行的结果和操作数的类型没有关系，换句话说，无论你是从无符号数的角度来看，还是从有符号数的角度来看，指令的执行结果都是正确无误的

```assembly
mov ah, 0xf0
inc ah

;这里0xf0的二进制形式是1111 0000 ，可以看做有符号数-16 ，也可以看做无符号数240
;当inc执行时，ah的内容是1111 0001 ，可以看做有符号数-15 ，也可以看做无符号数241
```

> 几乎所有的处理器指令既能操作无符号数，又能操作有符号数，但是：除法指令和乘法指令除外



div (Unsigned Divide)：这条指令只能用于工作无符号数

idiv(Signed Divide)：用于计算有符号数

idiv的扩展问题，计算时需要注意将符号位扩展到最高位，不然计算可能出错

