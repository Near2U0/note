[TOC]



# 中断和异常

中断包括硬件中断和软中断

* 硬中断

  硬件产生的中断

* 软中断

  由int n指令引发的中断，n是中断号或者类型码

* 内部中断（异常）

  指令执行过程中遇到了错误的状况

# 中断描述符表，中断门，陷阱门

实模式下，位于内存最低端的1KB内存，是中断向量表，定义了256种中断的入口地址，包括16位段地址和16位段内偏移地址

中断描述符表（Interrupt Descriptor Table, IDT)，保存的是和中断处理过程有关的描述符，包括中断门，陷阱门，任务门

中断门和陷阱门描述符只允许存放在IDT内，任务门可以位于GDT，LDT，IDT内，中断门和陷阱门仅仅有一比特的差别，和DGT一样，整个系统中只需要一个IDT就够了

在保护模式下的IDT不要求必须位于内存的最低端，事实上，在处理器内部，有一个48位的中断描述符表寄存器（Interrupt Descriptor Table Register，IDTR），保存着中断描述符表在内存中的线性基地址和界限

![](E:\git-workspace\note\images\linux\x86\1579073998566.png)



![](E:\git-workspace\note\images\linux\x86\1579074072021.png)



# 保护模式下中断处理过程

![1579074456820](E:\git-workspace\note\images\linux\x86\1579074456820.png)

上图是没有考虑分页的，也没有考虑任务门的情况

# 中断和异常处理程序的保护

![1579075096109](E:\git-workspace\note\images\linux\x86\1579075096109.png)

# 中断任务

当中断和异常发生时，如果根据中断向量从IDT中找到的描述符是任务门，则不是进行一般的中断处理过程，而是发生任务切换，如下是通过中断引起任务切换的原理

![1579075327049](E:\git-workspace\note\images\linux\x86\1579075327049.png)

# 错误代码

有些异常发生时，处理器会在异常处理程序或中断任务的栈中压入一个错误代码，压入栈中的错误代码是32位的，但高16位不用

![1579075689769](E:\git-workspace\note\images\linux\x86\1579075689769.png)

* EXT位：异常是由外部事件引发的（External Event），此位 置位时，表示异常是由NMI，硬件中断等引发的
* IDT位：用于指示描述符的位置，为1表示段选择子的索引部分（错误代码的位15-3）是指向中断描述符表（IDT）的，为0表示段选择子的索引部分指向GDT或者LDT
* TI位：在IDT为0时才有意义，TI=0表示段选择子的索引部分指向GDT，否则指向LDT

# 彻底终结多段模型

在平坦模型下，至少要创建两个描述符，一个是代码段，一个是数据段，都是4GB，主引导程序的加载位置是物理地址0x00007C00，在平坦模型下使用的基地址是0x00000000的代码段，为了继续执行程序，指令指针寄存器EIP的初始化内容必须是0x00007C00，并在此基础上随着指令的执行而增加

为了在平坦模型下方便的使用内存地址，这里定义了段mbr，并要求段的虚拟地址从0x00007C00开始

```assembly
SECTION mbr vstart=0x00007C00
;段内的偏移从0x00007C00开始计算
```














# 抢占式多任务

# 宏



