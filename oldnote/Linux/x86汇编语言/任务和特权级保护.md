[toc]

# 任务的隔离和特权级保护

* 程序

  记录在载体上的指令和数据，是为了完成某个特定的工作

* 任务

  程序运行的一个副本，所以内存中可以存在一个程序的多个副本，也就是多个任务，而加载到内存中的操作系统也是一个任务，只不过这个任务很大，这个任务有自己的描述符表GDT

* 任务的LDT

  每个任务有自己的描述符表LDT（Local Descriptor Table），将专属于自己的那些段放到LDT中，GDT是全局性的，有且只有一个

* LDTR

  用来追踪LDT的，和GDTR一样的功能，用于执行当前正在执行的任务，包含了32位的线性基地址字段和16位段界限字段

* TSS（Task State Segment）

  当任务切换的时候，需要保护现场，每个任务都有自己的额外的内存区域用于保护任务的状态

* TR（Task Register）

  指向TSS的寄存器，TR只有一个

![](/Users/chenyansong/Documents/note/images/linux/x86/image-20200101151322963.png)

![](/Users/chenyansong/Documents/note/images/linux/x86/SouthEast.png)



# 全局空间和局部空间

每个任务实际是包含两个部分：全局部分和局部部分

* 全局部分：所有任务共有的，包含有操作系统的软件和库程序，以及调用的系统服务和数据
* 私有部分：每个任务自己的数据和代码

全局部分和私有部分其实是地址空间的划分，即全局地址空间和局部地址空间，简称全局空间和局部空间

![](/Users/chenyansong/Documents/note/images/linux/x86/image-20200101153130424.png)![image-20200101153419696](/Users/chenyansong/Documents/note/images/linux/x86/image-20200101153419696.png)

全局地址空间是用全局描述符表（GDT）来指定的，而局部地址空间是由每个任务私有的局部描述符表（LDT）来定义的



# 特权级保护

* 特权级

  存在于描述符及其选择子中的一个数值，当这些描述符或者选择子所指向的对象要进行某种操作，或者被别的对象访问时，**该数值用于控制他们所能进行的操作或者限制他们的可访问性**

  Intel的处理器，可以识别4个特权级

  ![image-20200101155432448](/Users/chenyansong/Documents/note/images/linux/x86/image-20200101155432448.png)



* 目标对象特权级

  实施特权级保护的第一步，是为所有可管理的对象赋予一个特权级，以决定谁能访问他们，这就是描述符中的DPL字段，可以取值00，01，10，11，分别对应0，1，2，3特权级，DPL是每个描述符都有的字段，故称之为描述符特权级（Descriptor Privilege Level），也叫目标对象的特权级

* 当前特权级

  处理器正在一个代码段中取指令和执行指令时，那个代码段的特权级叫做当前特权级（Current Privilege Level，CPL），正在执行的这个代码段，其选择子位于段寄存器CS中，其最低两位就是当前特权级的数值

* 数据段的DPL检查

  决定了能够访问这个**数据段**的最低特权级，如果一个数据段的DPL=2，那么只有特权级0，1，2的**程序**才能访问这个数据段

* 代码段特权级检查

  控制转移只允许发生两个特权级相同的代码段之间

* 低特权级调用高特权级的方法
  
  如果低特权级，比如应用程序，想要调用高特权级，比如操作系统的例程，那么可以通过如下的方式进行：
  
  1. 将高特权级的代码段定义为依从的
  
     此时需要将代码段的描述符TYPE中的C=1，并且当前特权级的CPL和依从的代码段描述符的DPL，满足以下的关系
  
     ```cmd
     CPL >= 目标代码段描述符的DPL
     ```
  
     调用到依从的代码段时，并不改变当前代码段的CPL，即CS的CPL字段并没有发生变化，这就是为什么目标代码被称之为“依从的”代码段
  
  2. 在特权级之间转移控制的方法使用门
  
     门是另一种形式的描述符，称为门描述符，段描述符用于描述内存段，描述符则用于描述可执行的代码（比如一段程序，一个过程，或者一个任务）
  
     门的类型：
  
     1. 调用门：不同特权级之间的过程调用
     2. 中断门：中断处理过程使用
     3. 任务门：用来执行任务切换



# 调用门

可以通过调用门进行控制转移，可以使用jmp far或者call far指令，并把调用门描述符的选择子作为操作数

```shell
#jmp far 可以将控制通过门转移到比当前特权级高的代码段，但不改变当前特权级别
#call far 则当前特权级会提升到目标代码的特权级，也就是说处理器会在目标代码的特权级上执行

#不允许从特权级高的代码段将控制转移到特权级低的代码段，因为操作系统不会引用可靠性比自己低的代码
```









# 加载用户程序并创建任务







# 任务切换

