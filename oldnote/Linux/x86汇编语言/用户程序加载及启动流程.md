[TOC]

这里将主引导扇区改造成一个**程序加载器**(或者说是一个加载程序)，他的功能是加载用户程序，并执行该程序(将处理器的控制权交给该程序)

# 段

段的定义：section， segment，如果没有使用，默认所有的程序是一个段，这就是默认段

段的起始和结束：下一个段的开始就是上一个段的结束

段属性

* align：为了构造16字节对齐，不够的需要填充0

```shell
section.段名称.start
#段header相对于整个程序的开头的汇编地址是section.header.start
```

* vstart=0 相对于该段的起始偏移，否则就是相对于程序开始的位置的偏移量

# 用户程序结构

## 段的起始地址和段内汇编(偏移)地址

![](/Users/chenyansong/Documents/note/images/linux/x86/section.png)



## 用户程序头部


![image-20191225192859753](/Users/chenyansong/Documents/note/images/linux/x86/image-20191225192859753.png)


加载器需要知道用户程序的内部结构，所以用户程序会在头部放本程序的基本信息：

1. 用户程序的尺寸(单位字节)，加载器需要根据这个信息来决定读取多少个逻辑扇区
2. 用户程序的入口点，包括段地址和偏移地址，用户程序第一条指令的段地址和偏移地址，段地址是汇编阶段的地址，**在用户程序加载到内存那之后，需要根据加载的实际位置重新计算**
3. 段重定位表，需要确定每个段的起始地址，这里给出来的只是汇编地址，在程序加载到内存之后，每个段的地址必须重新确定(段的重定位是加载器的工作，需要在用户程序头部建立一张重定位表)
4. 段重定位表项个数(每个段重定位表项4字节)

![image-20191225194408250](/Users/chenyansong/Documents/note/images/linux/x86/image-20191225194408250.png)



# 程序加载器的工作流程

## 程序在内存和磁盘的位置

从磁盘的扇区加载到内存的什么地址处

![image-20191225195317859](/Users/chenyansong/Documents/note/images/linux/x86/image-20191225195317859.png)

## IO端口

IO端口：处理器是通过端口(Port)来和外围设备打交道的，端口本质上就是一些寄存器

连接硬盘的PATA/SATA接口就有几个端口：

1. 命令端口：当向该端口写入0x20时，表示从硬盘读数据；写入0x30时，表示向硬盘写数据
2. 状态端口：处理器根据这个端口的数据来判断硬盘是否正常工作，操作是否成功，发生了哪种错误
3. 参数端口：通过这个端口告诉硬盘读写的扇区数量，以及起始的逻辑扇区号
4. 数据端口：通过这个端口连续的取得读出的数据，或者通过这个端口连续的写入硬盘的数据

![image-20191225202318549](/Users/chenyansong/Documents/note/images/linux/x86/image-20191225202318549.png)



## IO寻址-独立编址

  1. 独立编址，比如有些IO设备
  2. 内存统一编址，映射到内存上的地址

  处理器的地址是既连接着内存，也连接着每一个IO接口，但是怎么知道是访问内存还是访问IO接口呢？

  处理器有一个特殊的引脚 M/IO#, 访问内存时会让M/IO#引脚呈现高电平，和内存相关的电路就会打开；相反，当处理器访问IO端口，那么M/IO#引脚呈现低电平，内存电路被禁止，此时，处理器发出的地址和M/IO#信号一起用于打开某个IO接口

  ![image-20191225204726919](/Users/chenyansong/Documents/note/images/linux/x86/image-20191225204726919.png)



在ICH芯片内部通常集成了两个PATA/SATA接口，分别是主硬盘接口和副硬盘接口，主硬盘接口分配的端口号是0x1f0-0x1f7，副硬盘接口分配的端口是0x170-0x177



## 端口数据写入，读出

```assembly
;从端口读数据; 一字节指令，因为源操作数和目的操作数都固定了
		;目的操作数必须是寄存器AL or AX ,当访问8位端口是AL, 当访问16位端口是AX
		;源操作数应当是DX
		;不允许使用别的寄存器或者是内存单元
in al, dx
in ax, dx

;2字节，后一个字节是立即数(故只能访问0-255号端口)
in al, 0xf0
in ax, 0x03



;向端口写
	;目的操作数可以是8位立即数或者寄存器DX
	;源操作数必须是AL or AX
out 0x37, al			;写0x37号端口(这是一个8位端口)
out 0xf5, ax			;写0xf5号端口(这是一个16位端口)
out dx, al				;这是一个8位端口，端口号在寄存器dx中
out dx, ax				;这是一个16位端口，端口号在寄存器dx中



```









# 用户程序的工作流程




